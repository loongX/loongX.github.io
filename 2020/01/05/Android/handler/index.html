<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>消息队列原理 | OKloong的博客</title>
  <meta name="keywords" content=" handler ">
  <meta name="description" content="消息队列原理 | OKloong的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="关于我 Android程序猿一枚 关于博客    认知的过程是由浅入深，知识体系也是由小到大的。每一次写文章都是建立在过去认知里写的，过去的认知可能不完善，而我的认知又会随着时间发展而变化的。鉴于这两者原因，我不认为我的博客一开始写就能一次性写好，就如学习的过程是循序渐进的，所以本博客将采用迭代的形式进行，您看到的每一篇文章都有可能不是它的终章。而我将为其作为知识库长期维护。">
<meta property="og:type" content="website">
<meta property="og:title" content="About me">
<meta property="og:url" content="https://okloong.com/about/index.html">
<meta property="og:site_name" content="OKloong的博客">
<meta property="og:description" content="关于我 Android程序猿一枚 关于博客    认知的过程是由浅入深，知识体系也是由小到大的。每一次写文章都是建立在过去认知里写的，过去的认知可能不完善，而我的认知又会随着时间发展而变化的。鉴于这两者原因，我不认为我的博客一开始写就能一次性写好，就如学习的过程是循序渐进的，所以本博客将采用迭代的形式进行，您看到的每一篇文章都有可能不是它的终章。而我将为其作为知识库长期维护。">
<meta property="article:published_time" content="2017-09-21T16:41:10.000Z">
<meta property="article:modified_time" content="2018-07-26T16:06:25.348Z">
<meta property="article:author" content="Okloong">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="OKloong的博客" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="true">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Okloong</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/loongX" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:long8086@foxmail.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(14)</small></div></li>
    
        
            
            <li><div data-rel="综合">综合<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Android">Android<small>(10)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="java">java<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="计算机">计算机<small>(2)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="14">
<input type="hidden" id="yelog_site_word_count" value="32.6k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color1">Annotation</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">Rxjava</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">综合</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">blog</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">handler</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">IntentService</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">apk</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">downlaodmanager</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">windowsmanager</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">NDK</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="Android "
           href="/2018/06/13/Android/Rxjava2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag="Rxjava"
           data-author="" >
            <span class="post-title" title="Rxjava2源码分析">Rxjava2源码分析</span>
            <span class="post-date" title="2018-06-13 11:13:01">2018/06/13</span>
        </a>
        
        <a  class="综合 "
           href="/2017/09/30/Comprehensive/StudyByFeedback/"
           data-tag="综合"
           data-author="" >
            <span class="post-title" title="反馈式学习">反馈式学习</span>
            <span class="post-date" title="2017-09-30 15:41:08">2017/09/30</span>
        </a>
        
        <a  class="计算机 "
           href="/2017/09/23/Comprehensive/Hexo_Blog/"
           data-tag="blog"
           data-author="" >
            <span class="post-title" title="Hexo博客搭建">Hexo博客搭建</span>
            <span class="post-date" title="2017-09-23 16:30:05">2017/09/23</span>
        </a>
        
        <a  class="java "
           href="/2020/01/05/Java/synchronized/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="synchronized">synchronized</span>
            <span class="post-date" title="2020-01-05 15:07:57">2020/01/05</span>
        </a>
        
        <a  class="计算机 "
           href="/2020/01/05/Computer/git-ssh-config/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git的ssh配置和使用">git的ssh配置和使用</span>
            <span class="post-date" title="2020-01-05 20:25:44">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/Intentservice/"
           data-tag="IntentService"
           data-author="" >
            <span class="post-title" title="IntentService耗时操作的原理">IntentService耗时操作的原理</span>
            <span class="post-date" title="2020-01-05 21:33:14">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/apk-build-process/"
           data-tag="apk"
           data-author="" >
            <span class="post-title" title="APK打包流程">APK打包流程</span>
            <span class="post-date" title="2020-01-05 21:20:56">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/downlaodmanager-download-app/"
           data-tag="downlaodmanager"
           data-author="" >
            <span class="post-title" title="DownlaodManager下载安装APP">DownlaodManager下载安装APP</span>
            <span class="post-date" title="2020-01-05 21:13:51">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/windowsmanager-attribute/"
           data-tag="windowsmanager"
           data-author="" >
            <span class="post-title" title="WindowManager的一些属性">WindowManager的一些属性</span>
            <span class="post-date" title="2020-01-05 21:17:01">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/ndk-so-file/"
           data-tag="NDK"
           data-author="" >
            <span class="post-title" title="NDK调用非JNI标准的so文件">NDK调用非JNI标准的so文件</span>
            <span class="post-date" title="2020-01-05 21:11:19">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/ndk-dynamicregistration/"
           data-tag="NDK"
           data-author="" >
            <span class="post-title" title="NDK动态注册">NDK动态注册</span>
            <span class="post-date" title="2020-01-05 21:08:01">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/ndk-base/"
           data-tag="NDK"
           data-author="" >
            <span class="post-title" title="NDK基础知识">NDK基础知识</span>
            <span class="post-date" title="2020-01-05 21:04:04">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2020/01/05/Android/handler/"
           data-tag="handler"
           data-author="" >
            <span class="post-title" title="消息队列原理">消息队列原理</span>
            <span class="post-date" title="2020-01-05 21:37:08">2020/01/05</span>
        </a>
        
        <a  class="Android "
           href="/2017/11/06/Android/Annotation/"
           data-tag="Annotation"
           data-author="" >
            <span class="post-title" title="Android注解">Android注解</span>
            <span class="post-date" title="2017-11-06 11:07:48">2017/11/06</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-Android/handler" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">消息队列原理</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="Android">Android</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color3">handler</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-01-05 21:40:19'>2020-01-05 21:37</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:6.3k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、基本用法"><span class="toc-text">一、基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#延时应用"><span class="toc-text">延时应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个线程发送消息，另外一个线程接收信息"><span class="toc-text">一个线程发送消息，另外一个线程接收信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取主线程"><span class="toc-text">获取主线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、原理"><span class="toc-text">二、原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Message"><span class="toc-text">Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler"><span class="toc-text">Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#post"><span class="toc-text">post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendMessage"><span class="toc-text">sendMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#postDelayed"><span class="toc-text">postDelayed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeCallbacks"><span class="toc-text">removeCallbacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Looper"><span class="toc-text">Looper</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文章将带你理解 Looper、Handler、Message三者的关系。</p>
<h1 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h1><h2 id="延时应用"><a href="#延时应用" class="headerlink" title="延时应用"></a>延时应用</h2><p>定时器应用</p>
<pre><code class="java">//一个定时器
    private Handler handler = new Handler();  

    private Runnable myRunnable= new Runnable() {    
        public void run() {  

            if (run) {  
                handler.postDelayed(this, 1000);  
                count++;  
            }  
            tvCounter.setText(&quot;Count: &quot; + count);  

        }  
    }; 

//然后在其他地方调用

handler.post(myRunnable);

handler.post(myRunnable,time);</code></pre>
<pre><code class="java">    new Thread(new Runnable() {
            @Override
            public void run() {
                //在子线程post一个Runnable对象
                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        //这里是消息处理的方法
                        //这里运行在主线程。
                    }
                });
            }
        }).start();</code></pre>
<h2 id="一个线程发送消息，另外一个线程接收信息"><a href="#一个线程发送消息，另外一个线程接收信息" class="headerlink" title="一个线程发送消息，另外一个线程接收信息"></a>一个线程发送消息，另外一个线程接收信息</h2><pre><code class="java">   //在主线程创建一个Handler对象。
    //重写Handler的handleMessage方法，这个就是接收并处理消息的方法。
    Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            //msg就是子线程发送过来的消息。
        }
    };

    //开启一个子线程
    new Thread(new Runnable() {
            @Override
            public void run() {
                //在子线程发送一个消息。
                Message msg = new Message();
                handler.sendMessage(msg);
            }
        }).start();</code></pre>
<pre><code class="java"> //声明Handler；
    Handler handler;
    new Thread(new Runnable() {
        @Override
        public void run() {
        //创建当前线程的Looper
            Looper.prepare();
            //在子线程创建handler对象
            handler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                //这里是消息处理，它是运行在子线程的
                }
           };
           //开启Looper的消息轮询
           Looper.loop();
       }
   }).start();

   mBanner.setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View v) {
       //在主线程发送一个消息到子线程
           Message msg = new Message();
           handler.sendMessage(msg);
       }
   });
//退出轮询
    Looper.myLooper().quit();
    Looper.myLooper().quitSafely();</code></pre>
<h2 id="获取主线程"><a href="#获取主线程" class="headerlink" title="获取主线程"></a>获取主线程</h2><p>Looper.getMainLooper()是获取主线程消息队列。</p>
<pre><code class="java">   new Thread(new Runnable() {
        @Override
        public void run() {
            //获取主线程的Looper
            Looper looper = Looper.getMainLooper();
            //用主线程的Looper创建Handler
            handler = new Handler(looper) {
                @Override
                public void handleMessage(Message msg) {
                //这里是运行在主线程的
                }
            };
        }
    }).start();</code></pre>
<p>取消某个消息</p>
<pre><code class="java">handler.removeCallbacksAndMessages(null); //取消所有的回调方法和message</code></pre>
<h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>\frameworks\base\core\java\android\os\Message.java</p>
<pre><code class="java">public final class Message implements Parcelable {
 /**
     * User-defined message code so that the recipient can identify
     * what this message is about. Each {@link Handler} has its own name-space
     * for message codes, so you do not need to worry about yours conflicting
     * with other handlers.
     */
    public int what;

    /**
     * arg1 and arg2 are lower-cost alternatives to using
     * {@link #setData(Bundle) setData()} if you only need to store a
     * few integer values.
     */
    public int arg1;

    /**
     * arg1 and arg2 are lower-cost alternatives to using
     * {@link #setData(Bundle) setData()} if you only need to store a
     * few integer values.
     */
    public int arg2;

    /**
     * An arbitrary object to send to the recipient.  When using
     * {@link Messenger} to send the message across processes this can only
     * be non-null if it contains a Parcelable of a framework class (not one
     * implemented by the application).   For other data transfer use
     * {@link #setData}.
     *
     * &lt;p&gt;Note that Parcelable objects here are not supported prior to
     * the {@link android.os.Build.VERSION_CODES#FROYO} release.
     */
    public Object obj;

    /**
     * Optional Messenger where replies to this message can be sent.  The
     * semantics of exactly how this is used are up to the sender and
     * receiver.
     */
    public Messenger replyTo;

    /**
     * Optional field indicating the uid that sent the message.  This is
     * only valid for messages posted by a {@link Messenger}; otherwise,
     * it will be -1.
     */
    public int sendingUid = -1;

    /** If set message is in use.
     * This flag is set when the message is enqueued and remains set while it
     * is delivered and afterwards when it is recycled.  The flag is only cleared
     * when a new message is created or obtained since that is the only time that
     * applications are allowed to modify the contents of the message.
     *
     * It is an error to attempt to enqueue or recycle a message that is already in use.
     */
    /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;

    /** If set message is asynchronous */
    /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;

    /** Flags to clear in the copyFrom method */
    /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;

    /*package*/ int flags;

    /*package*/ long when;

    /*package*/ Bundle data;

    /*package*/ Handler target;

    /*package*/ Runnable callback;

    // sometimes we store linked lists of these things
    /*package*/ Message next;

    private static final Object sPoolSync = new Object();
    private static Message sPool;
    private static int sPoolSize = 0;

    private static final int MAX_POOL_SIZE = 50;

    private static boolean gCheckRecycle = true;

    public static Message obtain() {
        synchronized (sPoolSync) {
            //如果消息池里面有空闲的消息可以用，则用消息池里面的。
            if (sPool != null) {
                //当前这条信息取自消息池里面的复用
                Message m = sPool;
                //取出消息池的下一条未用信息
                sPool = m.next;
                //当前这条链路掐断
                m.next = null;
                m.flags = 0; // clear in-use flag
                //消息池内信息减1
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
    /**
     * Same as {@link #obtain()}, but copies the values of an existing
     * message (including its target) into the new one.
     * @param orig Original message to copy.
     * @return A Message object from the global pool.
     */
    public static Message obtain(Message orig) {
        Message m = obtain();
        m.what = orig.what;
        m.arg1 = orig.arg1;
        m.arg2 = orig.arg2;
        m.obj = orig.obj;
        m.replyTo = orig.replyTo;
        m.sendingUid = orig.sendingUid;
        if (orig.data != null) {
            m.data = new Bundle(orig.data);
        }
        m.target = orig.target;
        m.callback = orig.callback;

        return m;
    }

    /**
     * Same as {@link #obtain()}, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned.
     * @param h  Handler to assign to the returned Message object&#39;s &lt;em&gt;target&lt;/em&gt; member.
     * @return A Message object from the global pool.
     */
    public static Message obtain(Handler h) {
        Message m = obtain();
        m.target = h;

        return m;
    }

    /**
     * Same as {@link #obtain(Handler)}, but assigns a callback Runnable on
     * the Message that is returned.
     * @param h  Handler to assign to the returned Message object&#39;s &lt;em&gt;target&lt;/em&gt; member.
     * @param callback Runnable that will execute when the message is handled.
     * @return A Message object from the global pool.
     */
    public static Message obtain(Handler h, Runnable callback) {
        Message m = obtain();
        m.target = h;
        m.callback = callback;

        return m;
    }

        /**
     * Same as {@link #obtain()}, but sets the values for both &lt;em&gt;target&lt;/em&gt; and
     * &lt;em&gt;what&lt;/em&gt; members on the Message.
     * @param h  Value to assign to the &lt;em&gt;target&lt;/em&gt; member.
     * @param what  Value to assign to the &lt;em&gt;what&lt;/em&gt; member.
     * @return A Message object from the global pool.
     */
    public static Message obtain(Handler h, int what) {
        Message m = obtain();
        m.target = h;
        m.what = what;

        return m;
    }


    /**
     * Return a Message instance to the global pool.
     * &lt;p&gt;
     * You MUST NOT touch the Message after calling this function because it has
     * effectively been freed.  It is an error to recycle a message that is currently
     * enqueued or that is in the process of being delivered to a Handler.
     * &lt;/p&gt;
     */
     //回收消息
    public void recycle() {
        if (isInUse()) {
            if (gCheckRecycle) {
                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;
                        + &quot;is still in use.&quot;);
            }
            return;
        }
        recycleUnchecked();
    }

    /**
     * Recycles a Message that may be in-use.
     * Used internally by the MessageQueue and Looper when disposing of queued Messages.
     */
    void recycleUnchecked() {
        // Mark the message as in use while it remains in the recycled object pool.
        // Clear out all other details.
        flags = FLAG_IN_USE;
        what = 0;
        arg1 = 0;
        arg2 = 0;
        obj = null;
        replyTo = null;
        sendingUid = -1;
        when = 0;
        target = null;
        callback = null;
        data = null;

        synchronized (sPoolSync) {
            //消息池里面只保留MAX_POOL_SIZE条空闲的信息，这些信息等待下次使用。
            //如果实际消息池里面的数量还不够50条，则回收这一条信息,
            if (sPoolSize &lt; MAX_POOL_SIZE) {
                //当前这条信息连接好消息池里面空闲信息头
                next = sPool;
                //回收好当前这条信息
                sPool = this;
                //消息池内消息数量加1
                sPoolSize++;
            }
        }
    }
    ......//还有set/get参数、序列化等等方法就不罗列了。
}</code></pre>
<p>Message主要的实例属性是what ，arg1 ，arg2 ，obj,target，callback，next。what是主要是识别身份的，arg1，arg2是int参数，obj是传递的对象的，一般是作为令牌（token）来用，target是所用的handler。callback是Runnable， 需要的时候Run里面的任务。next是下一条message。message之间连成链式连接，这就是消息队列。消息队列是单向链表。<br>可以看到<code>public static Message obtain()</code>里面会根据原来有没有message来创建，如果有，拿出消息池里面的message出来用，sPoolSize–，如果没有则新建一条。message线程池的大小是50条，MAX_POOL_SIZE = 50。消息池实质是回收消息池，消息数目是可以超过50条的，只是消息池会回收最多50条用完的消息来存着备用。<br>obtain有好几个重载。</p>
<pre><code class="java">public static Message obtain(Handler h)
public static Message obtain(Handler h, Runnable callback)
public static Message obtain(Handler h, int what)
public static Message obtain(Handler h, int what, Object obj) 
public static Message obtain(Handler h, int what, int arg1, int arg2)
public static Message obtain(Handler h, int what, int arg1, int arg2, Object obj)</code></pre>
<p>可以根据自己需要创建不同参数的message。<br>recycle() 是回收message用的。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p>当用post发送Runnable 时候，它们是进行下面操作。<br>\frameworks\base\core\java\android\os\Handler.java</p>
<pre><code class="java">    /**
     * Causes the Runnable r to be added to the message queue.
     * The runnable will be run on the thread to which this handler is 
     * attached. 
     *  
     * @param r The Runnable that will be executed.
     * 
     * @return Returns true if the Runnable was successfully placed in to the 
     *         message queue.  Returns false on failure, usually because the
     *         looper processing the message queue is exiting.
     */
    public final boolean post(Runnable r)
    {
        //设置定时为0，用getPostMessage新建了一message
       return  sendMessageDelayed(getPostMessage(r), 0);
    }

    //这里新建了一个Mssage,然后把Runnable 放进去。
    private static Message getPostMessage(Runnable r) {
        Message m = Message.obtain();
        m.callback = r;
        return m;
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        //获取当前消息队列
         MessageQueue queue = mQueue;
         //如果当前消息队列为空，则失败
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        //处理消息队列里面的消息。
        return enqueueMessage(queue, msg, uptimeMillis);
    }
    //处理消息队列里面的消息。
    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        //调用消息队列里面的enqueueMessage，传进去消息和延时时间，这个实例里面传的是0.
        return queue.enqueueMessage(msg, uptimeMillis);
    }</code></pre>
<p>消息队列处理<br>\frameworks\base\core\java\android\os\MessageQueue.java</p>
<pre><code class="java">    //消息排队，主要是刷选将要执行的消息，并把新消息入队。
    boolean enqueueMessage(Message msg, long when) {
        //检查handler是否有
        if (msg.target == null) {
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }
        //异步操作
        synchronized (this) {
            //表示当前队列是否处于正在退出状态
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            //设置延时时间
            msg.when = when;
            //    Message mMessages;这个是链头，也相当于指针的作用了。
            Message p = mMessages;
            boolean needWake;
            //p == null 意味着到尾了。when == 0是立刻执行。when &lt; p.when是比下一个message要早时间执行。
            //此时消息队列是有序排列的，按时间先后顺序。
            if (p == null || when == 0 || when &lt; p.when) {
                // New head, wake up the event queue if blocked.
                //唤醒执行。设置当前消息为要执行消息。
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {//当前消息不是要将要执行消息。有其他消息需要先执行
                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
               //Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.
               //private boolean mBlocked;    

                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                //这个主要是要找msge插入到队列的位置。
                for (;;) {
                    //用prev来指向当前队列的某个mssage，如果找到这个message将排在msg之前，p找下一个mssage
                    prev = p;
                    //找下链条里面的一个mssage，直到找完整个队列或者找到执行时间要比当前时间要长的。
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                //插入队列适合的位置
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            //这里看是否唤醒线程循环，这里用到epoll技术
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }</code></pre>
<p>上面的操作已经把消息打入队列里面了。此时队列是有序排列的。</p>
<h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><p>发送消息<br>\frameworks\base\core\java\android\os\Handler.java</p>
<pre><code class="java">    /**
     * Pushes a message onto the end of the message queue after all pending messages
     * before the current time. It will be received in {@link #handleMessage},
     * in the thread attached to this handler.
     *  
     * @return Returns true if the message was successfully placed in to the 
     *         message queue.  Returns false on failure, usually because the
     *         looper processing the message queue is exiting.
     */
    public final boolean sendMessage(Message msg)
    {
        //设置为0是立刻执行
        return sendMessageDelayed(msg, 0);
    }

    /**
     * Enqueue a message into the message queue after all pending messages
     * before (current time + delayMillis). You will receive it in
     * {@link #handleMessage}, in the thread attached to this handler.
     *  
     * @return Returns true if the message was successfully placed in to the 
     *         message queue.  Returns false on failure, usually because the
     *         looper processing the message queue is exiting.  Note that a
     *         result of true does not mean the message will be processed -- if
     *         the looper is quit before the delivery time of the message
     *         occurs then the message will be dropped.
     */
    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        //SystemClock.uptimeMillis()表示系统开机到当前的时间总数，单位是毫秒，
        //但是，当系统进入深度睡眠（CPU休眠、屏幕休眠、设备等待外部输入）时间就会停止，
        //但是不会受到时钟缩放、空闲或者其他节能机制的影响。
        //这里是延时加当前系统时间，表示未来要执行的时间点。
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        //消息队列排队
        return enqueueMessage(queue, msg, uptimeMillis);
    }
    //把消息放到队列里面
    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }</code></pre>
<p>queue.enqueueMessage是根据放进去的消息来排列，上面已经说了原理。</p>
<h3 id="postDelayed"><a href="#postDelayed" class="headerlink" title="postDelayed"></a>postDelayed</h3><p>基本原理和sendMessage一样</p>
<p>\frameworks\base\core\java\android\os\Handler.java</p>
<pre><code class="java">    public final boolean postDelayed(Runnable r, long delayMillis)
    {
        //生成一个新的mssage，设置好延时毫秒
        return sendMessageDelayed(getPostMessage(r), delayMillis);
    }

    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        //系统启动时间加要延时时间
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        //加入消息队列里面
        return enqueueMessage(queue, msg, uptimeMillis);
    }
    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }</code></pre>
<p>延时在消息从系统启动时间算起，看延时到哪个点，然后放到消息队列里面。</p>
<h3 id="removeCallbacks"><a href="#removeCallbacks" class="headerlink" title="removeCallbacks"></a>removeCallbacks</h3><p>移除Callback<br>\frameworks\base\core\java\android\os\Handler.java</p>
<pre><code class="java">    /**
     * Remove any pending posts of Runnable r that are in the message queue.
     */
    public final void removeCallbacks(Runnable r)
    {
        mQueue.removeMessages(this, r, null);
    }</code></pre>
<p>从消息队列里匹对消息然后移除该消息<br>\frameworks\base\core\java\android\os\MessageQueue.java</p>
<pre><code class="java">    void removeMessages(Handler h, Runnable r, Object object) {
        if (h == null || r == null) {
            return;
        }

        synchronized (this) {
            //mMessages是消息队列的队首
            Message p = mMessages;

            // Remove all messages at front.
            //这里用循环来匹配消息内容，如果找到了，则把该条massage移除。
            //从队首开始删除，如果删除了队首就指向接下来的元素。
            while (p != null &amp;&amp; p.target == h &amp;&amp; p.callback == r
                   &amp;&amp; (object == null || p.obj == object)) {
                   //令mMessages为下一个mssage 
                Message n = p.next;
                mMessages = n;
                //这里回收消息
                p.recycleUnchecked();
                p = n;
            }

            // Remove all messages after front.
            //如果不为结尾继续循环，移除找到的Message
            while (p != null) {
                Message n = p.next;
                //如果下一条不是结尾还是有的话继续处理
                if (n != null) {
                    //匹配当前消息
                    if (n.target == h &amp;&amp; n.callback == r
                        &amp;&amp; (object == null || n.obj == object)) {
                        Message nn = n.next;
                        n.recycleUnchecked();
                        p.next = nn;
                        continue;
                    }
                }
                p = n;
            }
        }
    }</code></pre>
<p><code>handler.removeCallbacksAndMessages(null);</code>是用来清空消息队列的，此时匹对的消息的obj都是为null。</p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>经过handler把消息压进了消息队列，需要一个循环逐一拿出来用，这个循环是Looper。在调用中用<code>Looper.loop();</code>来开启。</p>
<pre><code class="java"> //声明Handler；
    Handler handler;
    new Thread(new Runnable() {
        @Override
        public void run() {
        //创建当前线程的Looper
            Looper.prepare();
            //在子线程创建handler对象
            handler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                //这里是消息处理，它是运行在子线程的
                }
           };
           //开启Looper的消息轮询
           Looper.loop();
       }
   }).start();</code></pre>
<p>\frameworks\base\core\java\android\os\Looper.java</p>
<pre><code class="java">public final class Looper {
    /*
     * API Implementation Note:
     *
     * This class contains the code required to set up and manage an event loop
     * based on MessageQueue.  APIs that affect the state of the queue should be
     * defined on MessageQueue or Handler rather than on Looper itself.  For example,
     * idle handlers and sync barriers are defined on the queue whereas preparing the
     * thread, looping, and quitting are defined on the looper.
     */

    private static final String TAG = &quot;Looper&quot;;

    // sThreadLocal.get() will return null unless you&#39;ve called prepare().
    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
    //主线程调用的Looper
    private static Looper sMainLooper;  // guarded by Looper.class

    final MessageQueue mQueue;
    final Thread mThread;

    private Printer mLogging;
    private long mTraceTag;

    /* If set, the looper will show a warning log if a message dispatch takes longer than time. */
    private long mSlowDispatchThresholdMs;

     /** Initialize the current thread as a looper.
      * This gives you a chance to create handlers that then reference
      * this looper, before actually starting the loop. Be sure to call
      * {@link #loop()} after calling this method, and end it by calling
      * {@link #quit()}.
      */
      //线程里面构建一个新的looper，Looper.prepare();每一个Looper对象会和一个线程关联 
      //Looper对象创建时会创建一个MessageQueue,一般其他线程要这个looper要调用Looper.prepare()
    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

    /**
     * Initialize the current thread as a looper, marking it as an
     * application&#39;s main looper. The main looper for your application
     * is created by the Android environment, so you should never need
     * to call this function yourself.  See also: {@link #prepare()}
     */
    //这个主线程的looper，一般是系统来调用的
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }

    /**
     * Returns the application&#39;s main looper, which lives in the main thread of the application.
     */
     //这个是获取主线程的Looper，UI线程的大循环是这里取得
     //如果你想建立一个UI更新的handler，可以这么操作
     //Handler mhandler = new Handler(Looper.getMainLooper);
    public static Looper getMainLooper() {
        synchronized (Looper.class) {
            return sMainLooper;
        }
    }

    /**
     * Run the message queue in this thread. Be sure to call
     * {@link #quit()} to end the loop.
     */
     //Looper.loop就是这个循环
    public static void loop() {
        //sThreadLocal里面获取当前的ThreadLocal，其实是Looper对象。
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);
        }
        //获取当前Looper的消息队列
        final MessageQueue queue = me.mQueue;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();
        //死循环
        for (;;) {
            //查找下一条消息,消息队列里面保存有mMessages，这个是链头
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                //如果没有消息则打断死循环跳出去
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                        msg.callback + &quot;: &quot; + msg.what);
            }

            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;

            final long traceTag = me.mTraceTag;
            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {
                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
            }
            //SystemClock.uptimeMillis() 从开机到现在的毫秒数（手机睡眠的时间不包括在内）
            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
            final long end;
            try {
                //这里调用的是handler里面的dispatchMessage(Message msg)方法，
                //它将会调用我们自己定义的handleMessage方法。
                msg.target.dispatchMessage(msg);
                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }
            //根据需要算时间差
            if (slowDispatchThresholdMs &gt; 0) {
                final long time = end - start;
                if (time &gt; slowDispatchThresholdMs) {
                    Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;
                            + Thread.currentThread().getName() + &quot;, h=&quot; +
                            msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);
                }
            }

            if (logging != null) {
                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn&#39;t corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                        + Long.toHexString(ident) + &quot; to 0x&quot;
                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                        + msg.target.getClass().getName() + &quot; &quot;
                        + msg.callback + &quot; what=&quot; + msg.what);
            }
            //消息回收，这里的消息池内会回收消息。
            msg.recycleUnchecked();
        }
    }


    /**
     * Return the Looper object associated with the current thread.  Returns
     * null if the calling thread is not associated with a Looper.
     */
     //获取当前thread的threadload
    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }

    /**
     * Return the {@link MessageQueue} object associated with the current
     * thread.  This must be called from a thread running a Looper, or a
     * NullPointerException will be thrown.
     */
     //获取threadload里面的消息队列
    public static @NonNull MessageQueue myQueue() {
        return myLooper().mQueue;
    }

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

    /**
     * Returns true if the current thread is this looper&#39;s thread.
     */
    public boolean isCurrentThread() {
        return Thread.currentThread() == mThread;
    }

    ......
}</code></pre>
<p>大致的处理过程是获取当前线程的looper，然后获取looper里面的消息队列，然后一个个处理消息队列里面的消息，处理完就回收消息。</p>
<p>loop()里面的msg.target.dispatchMessage(msg);是调用了我们定义消息处理动作了。dispatchMessage里面是调用handleCallback或者handleMessage。dispatchMessage是Handler里面的方法。<br>\frameworks\base\core\java\android\os\Handler.java</p>
<pre><code class="java">    /**
     * Handle system messages here.
     */
    public void dispatchMessage(Message msg) {
        //判断是否为空
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            //这里检查Callback 有没有被实现，如果有则调用改接口的handleMessage
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            //这一步是调用我们定义的内容
            handleMessage(msg);
        }
    }

    //如果有callback则run，callback是一个Runnable
    private static void handleCallback(Message message) {
        message.callback.run();
    }

//handleMessage是我们定义的处理信息的动作了。
    /**
     * Callback interface you can use when instantiating a Handler to avoid
     * having to implement your own subclass of Handler.
     *
     * @param msg A {@link android.os.Message Message} object
     * @return True if no further handling is desired
     */
    public interface Callback {
        public boolean handleMessage(Message msg);
    }

    /**
     * Subclasses must implement this to receive messages.
     */
    public void handleMessage(Message msg) {
    }</code></pre>
<p>看下<code>Message msg = queue.next();</code>里面执行了什么。<br>\frameworks\base\core\java\android\os\MessageQueue.java</p>
<pre><code class="java">public final class MessageQueue {
    Message mMessages;
    ......
    Message next() {
        // Return here if the message loop has already quit and been disposed.
        // This can happen if the application tries to restart a looper after quit
        // which is not supported.
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
            //这个nextPollTimeoutMillis 是上一次消息处理适合设置的下一次唤醒时间，没到时间就休眠
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }
            //阻塞
            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                //这里主要是检索吓一条mssage。如果找到就返回。
                //获取当前的时间。这个时间是系统开机时间，用毫秒表示。
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                //获取消息队列的头
                Message msg = mMessages;
                //如果handler没写好就一直找到下一个设置好target的message为止。
                if (msg != null &amp;&amp; msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null &amp;&amp; !msg.isAsynchronous());
                }
                if (msg != null) {
                    //看下时间到了没。
                    //注意你之前设定的定时信息在这里其作用了。没到点不执行。
                    if (now &lt; msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        //下一条信息还没到时间执行。
                        //设置下一次执行的唤醒时间
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        //下一条信息到时间执行了，取出来。
                        mBlocked = false;
                        //如果该条信息还有前一条信息则设置好前一条信息的链路
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            //设置队列头为下一条信息
                            mMessages = msg.next;
                        }
                        //断开链路，单独取出来。
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    //没有消息了
                    nextPollTimeoutMillis = -1;
                }
                //消息都已经执行，并清空了。执行下面的流程。
                //其实是设置epoll的唤醒时间

                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }
                //IdleHandler 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情
                //（譬如 UI 线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。

                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount &lt; 0
                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount &lt;= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            //循环遍历所有IdleHandler
            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }
    ......
 }</code></pre>
<p>MessageQueue.mMessages-&gt;( Message并且Message.next)-&gt; ( Message并且Message.next)-&gt;…–&gt;null 构成一个单向链表。<code>Message msg = queue.next();</code>是拿出下一条message出来，如果设置了定时，没到时间就会拿出来。拿出来后通过<code>msg.target.dispatchMessage(msg);</code>来执行。这个looper是个循环，有消息就处理，没消息就阻塞，通过epoll机制来调整运行状态。在塞信息进入消息队列适合会判断是否唤醒循环<code>nativeWake(mPtr);</code></p>
<p>next里面的阻塞代码是下面这个。阻塞是发生在nativePollOnce方法，在native层使用了epoll机制来等待消息。</p>
<pre><code class="java">//private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/
for (;;) {
    if (nextPollTimeoutMillis != 0) {
        Binder.flushPendingCommands();
    }
    nativePollOnce(ptr, nextPollTimeoutMillis);

    //...
}</code></pre>
<p>退出消息队列</p>
<p>\frameworks\base\core\java\android\os\Looper.java</p>
<pre><code class="java">    /**
     * Quits the looper.
     * &lt;p&gt;
     * Causes the {@link #loop} method to terminate without processing any
     * more messages in the message queue.
     * &lt;/p&gt;&lt;p&gt;
     * Any attempt to post messages to the queue after the looper is asked to quit will fail.
     * For example, the {@link Handler#sendMessage(Message)} method will return false.
     * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt;
     * Using this method may be unsafe because some messages may not be delivered
     * before the looper terminates.  Consider using {@link #quitSafely} instead to ensure
     * that all pending work is completed in an orderly manner.
     * &lt;/p&gt;
     *
     * @see #quitSafely
     */
    public void quit() {
        mQueue.quit(false);
    }

    /**
     * Quits the looper safely.
     * &lt;p&gt;
     * Causes the {@link #loop} method to terminate as soon as all remaining messages
     * in the message queue that are already due to be delivered have been handled.
     * However pending delayed messages with due times in the future will not be
     * delivered before the loop terminates.
     * &lt;/p&gt;&lt;p&gt;
     * Any attempt to post messages to the queue after the looper is asked to quit will fail.
     * For example, the {@link Handler#sendMessage(Message)} method will return false.
     * &lt;/p&gt;
     */
    public void quitSafely() {
        mQueue.quit(true);
    }</code></pre>
<p>\frameworks\base\core\java\android\os\MessageQueue.java</p>
<pre><code class="java">    void quit(boolean safe) {
        if (!mQuitAllowed) {
            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                return;
            }
            mQuitting = true;

            if (safe) {
                removeAllFutureMessagesLocked();
            } else {
                removeAllMessagesLocked();
            }

            // We can assume mPtr != 0 because mQuitting was previously false.
            nativeWake(mPtr);
        }
    }
//可以从代码看出退出队列会把队列清空
    private void removeAllMessagesLocked() {
        Message p = mMessages;
        while (p != null) {
            Message n = p.next;
            p.recycleUnchecked();
            p = n;
        }
        mMessages = null;
    }

    private void removeAllFutureMessagesLocked() {
        final long now = SystemClock.uptimeMillis();
        Message p = mMessages;
        if (p != null) {
            if (p.when &gt; now) {
                removeAllMessagesLocked();
            } else {
                Message n;
                //如果队列头不是未来要执行的message的话，则继续找，找到为止。然后再回收那些未来某个点执行的message。
                for (;;) {
                    n = p.next;
                    if (n == null) {
                        return;
                    }
                    if (n.when &gt; now) {
                        break;
                    }
                    //在链表里面找到不是立即执行的message，然后断开，再回收那些未来要执行的message
                    p = n;
                }
                //这里是为了链表断开那些定时和没定时的message
                p.next = null;
                //定时执行的message将被回收。
                do {
                    p = n;
                    n = p.next;
                    p.recycleUnchecked();
                } while (n != null);
            }
        }
    }</code></pre>
<p>looper里面的quit()或quitSafely()可以退出消息队列，从代码看出退出队列会把队列清空。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 long8086@foxmail.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>消息队列原理</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">6.3k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="Okloong">Okloong</a></p>
    <p><span class="copy-title">发布时间:</span>2020-01-05, 21:37:08</p>
    <p><span class="copy-title">最后更新:</span>2020-01-05, 21:40:19</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/01/05/Android/handler/" title="消息队列原理">https://okloong.com/2020/01/05/Android/handler/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'e9e594c7c1e40451b0c0',
            clientSecret: '69e909bee5f73eb321d7764126cde7ec7c73513f',
            repo: 'loongX.github.io',
            owner: 'loongX',
            admin: ['loongX'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2020 Okloong</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#Annotation','#Rxjava','#综合','#blog','#java','#git','#handler','#IntentService','#apk','#downlaodmanager','#windowsmanager','#NDK',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
