<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Timber原理解析</title>
      <link href="/2020/01/06/Timber/"/>
      <url>/2020/01/06/Timber/</url>
      
        <content type="html"><![CDATA[<p>Timber初始化设置。</p><pre><code class="java">        Timber.plant(new Timber.DebugTree());        Timber.plant(new Timber.DebugTree() {            @Override            protected void log(int priority, String tag, @NotNull String message, Throwable t) {//                super.log(priority, tag, message, t);                switch (priority) {                    case Log.DEBUG:                        ILog.d(tag, message);                        break;                    case Log.INFO:                        ILog.i(tag, message);                        break;                    case Log.WARN:                        ILog.w(tag, message);                        break;                    case Log.ERROR:                        ILog.e(tag, message);                        break;                    case Log.ASSERT:                        ILog.a(tag, message);                        break;                    case Log.VERBOSE:                        ILog.v(tag, message);                        break;                }            }        });       Logger.addLogAdapter(new AndroidLogAdapter());        Timber.plant(new Timber.DebugTree() {            @Override            protected void log(int priority, String tag, String message, Throwable t) {                Logger.log(priority, tag, message, t);            }        });</code></pre><p>可以要设置一般是设置 log(int priority, String tag, @NotNull String message, Throwable t)的方法。里面的<code>super.log(priority, tag, message, t);</code>是显示控制台打印，如果你加入的log框架里面已经有控制打印可以不用，要不然你每次都会看到两行一模一样的log信息打印出来。<code>Timber.plant</code>可以加多几个log框架来控制。</p><p>Timeber调用方法。</p><pre><code class="java">        Timber.tag(TAG).d(&quot;ddddd&quot;);        Timber.tag(TAG).i(&quot;iii&quot;);        Timber.tag(TAG).v(&quot;vvv&quot;);        Timber.tag(TAG).e(&quot;eeee&quot;);        Timber.tag(TAG).w(&quot;wwww&quot;);        String mac = getMacFromHardware();        Timber.tag(TAG).i(&quot;mac: &quot; + mac);        Timber.i(&quot;mac: &quot; + mac);</code></pre><p>Timeber打印log大致有两种方式。一种是像<code>Timber.tag(TAG).i(&quot;iii&quot;);</code>这样的，另外一种是不加tag的<code>Timber.i(&quot;mac: &quot; + mac);</code>这种tag是自动获取的，下面会讲到getStackTrace的方式获取。</p><p>下面来看<code>Timber.i</code>会调用到什么东西。</p><pre><code class="java">    public static void d(Throwable t, @NonNls String message, Object... args) {    TREE_OF_SOULS.d(t, message, args);  }  public static void i(Throwable t, @NonNls String message, Object... args) {    TREE_OF_SOULS.i(t, message, args);  }    public static void wtf(Throwable t, @NonNls String message, Object... args) {    TREE_OF_SOULS.wtf(t, message, args);  }</code></pre><p>TREE_OF_SOULS是一个总调的方式，里面调用的是各种log策略。<br>在Timber的变量来看。TREE_OF_SOULS里面各个方法用遍历的方式查询和调用各种log策略。</p><pre><code class="java">       //空的tree，主要是清空的时候用。      private static final Tree[] TREE_ARRAY_EMPTY = new Tree[0];  // Both fields guarded by &#39;FOREST&#39;.  private static final List&lt;Tree&gt; FOREST = new ArrayList&lt;&gt;();//记载各种策略  static volatile Tree[] forestAsArray = TREE_ARRAY_EMPTY;// tree数列    /** A {@link Tree} that delegates to all planted trees in the {@linkplain #FOREST forest}. */  private static final Tree TREE_OF_SOULS = new Tree() {    @Override public void v(String message, Object... args) {      Tree[] forest = forestAsArray;      for (Tree tree : forest) {        tree.v(message, args);      }    }    @Override public void v(Throwable t, String message, Object... args) {      Tree[] forest = forestAsArray;      for (Tree tree : forest) {        tree.v(t, message, args);      }    }    @Override public void v(Throwable t) {      Tree[] forest = forestAsArray;      for (Tree tree : forest) {        tree.v(t);      }    }    @Override public void d(String message, Object... args) {      Tree[] forest = forestAsArray;      for (Tree tree : forest) {        tree.d(message, args);      }    }    ......    @Override protected void log(int priority, String tag, @NotNull String message, Throwable t) {      throw new AssertionError(&quot;Missing override for log method.&quot;);    }  };</code></pre><pre><code class="java">//不让创建，作为工具类用。  private Timber() {    throw new AssertionError(&quot;No instances.&quot;);  }</code></pre><p>设置tag。</p><pre><code class="java">  /** Set a one-time tag for use on the next logging call. */  @NotNull  public static Tree tag(String tag) {    Tree[] forest = forestAsArray;    for (Tree tree : forest) {      tree.explicitTag.set(tag);    }    return TREE_OF_SOULS;  }</code></pre><p>这个是上面调用Timber.tag设置的Tag。explicitTag是对应到Tree里面的ThreadLocal。</p><p>下面这个是Tree的类。可以看到explicitTag和getTag是和tag设置是有关的。然后下面各个等级的日记调用都是调用prepareLog。</p><pre><code class="java">  public static abstract class Tree {    final ThreadLocal&lt;String&gt; explicitTag = new ThreadLocal&lt;&gt;();    @Nullable    String getTag() {      String tag = explicitTag.get();      if (tag != null) {        explicitTag.remove();      }      return tag;    }        /** Log an info message with optional format args. */    public void i(String message, Object... args) {      prepareLog(Log.INFO, null, message, args);    }    /** Log an info exception and a message with optional format args. */    public void i(Throwable t, String message, Object... args) {      prepareLog(Log.INFO, t, message, args);    }    /** Log an info exception. */    public void i(Throwable t) {      prepareLog(Log.INFO, t, null);    }   ......        private void prepareLog(int priority, Throwable t, String message, Object... args) {      // Consume tag even when message is not loggable so that next message is correctly tagged.      String tag = getTag();//这里是设置限制log信息打印的，可以更改该方法下的返回值来控制。      if (!isLoggable(tag, priority)) {        return;      }      if (message != null &amp;&amp; message.length() == 0) {        message = null;      }      if (message == null) {        if (t == null) {          return; // Swallow message if it&#39;s null and there&#39;s no throwable.        }        message = getStackTraceString(t);      } else {        if (args != null &amp;&amp; args.length &gt; 0) {          message = formatMessage(message, args);        }        if (t != null) {          message += &quot;\n&quot; + getStackTraceString(t);        }      }      log(priority, tag, message, t);    }        /**     * Formats a log message with optional arguments.     */    protected String formatMessage(@NotNull String message, @NotNull Object[] args) {      return String.format(message, args);    }       private String getStackTraceString(Throwable t) {      // Don&#39;t replace this with Log.getStackTraceString() - it hides      // UnknownHostException, which is not what we want.      StringWriter sw = new StringWriter(256);      PrintWriter pw = new PrintWriter(sw, false);      t.printStackTrace(pw);      pw.flush();      return sw.toString();    }    /**     * Write a log message to its destination. Called for all level-specific methods by default.     *     * @param priority Log level. See {@link Log} for constants.     * @param tag Explicit or inferred tag. May be {@code null}.     * @param message Formatted log message. May be {@code null}, but then {@code t} will not be.     * @param t Accompanying exceptions. May be {@code null}, but then {@code message} will not be.     */    protected abstract void log(int priority, @Nullable String tag, @NotNull String message,        @Nullable Throwable t);   }</code></pre><p>prepareLog是整理log信息用的，把可能的Throwable和Message整理在一起。</p><p>好了，下面看下plant方法是这么调用的。</p><pre><code class="java">  /** Add a new logging tree. */  @SuppressWarnings(&quot;ConstantConditions&quot;) // Validating public API contract.  public static void plant(@NotNull Tree tree) {    if (tree == null) {      throw new NullPointerException(&quot;tree == null&quot;);    }    if (tree == TREE_OF_SOULS) {      throw new IllegalArgumentException(&quot;Cannot plant Timber into itself.&quot;);    }    synchronized (FOREST) {      FOREST.add(tree);      forestAsArray = FOREST.toArray(new Tree[FOREST.size()]);    }  }</code></pre><p>plant是设置各种策略用的，它的目的是把策略保存在一个数列中，FOREST和forestAsArray。</p><p>DebugTree类是里面提供的一个参考类。</p><pre><code class="java"> /** A {@link Tree Tree} for debug builds. Automatically infers the tag from the calling class. */  public static class DebugTree extends Tree {    private static final int MAX_LOG_LENGTH = 4000;    private static final int MAX_TAG_LENGTH = 23;    private static final int CALL_STACK_INDEX = 5;    private static final Pattern ANONYMOUS_CLASS = Pattern.compile(&quot;(\\$\\d+)+$&quot;);    /**     * Extract the tag which should be used for the message from the {@code element}. By default     * this will use the class name without any anonymous class suffixes (e.g., {@code Foo$1}     * becomes {@code Foo}).     * &lt;p&gt;     * Note: This will not be called if a {@linkplain #tag(String) manual tag} was specified.     */    @Nullable    protected String createStackElementTag(@NotNull StackTraceElement element) {      String tag = element.getClassName();      Matcher m = ANONYMOUS_CLASS.matcher(tag);      if (m.find()) {        tag = m.replaceAll(&quot;&quot;);      }      tag = tag.substring(tag.lastIndexOf(&#39;.&#39;) + 1);      // Tag length limit was removed in API 24.      if (tag.length() &lt;= MAX_TAG_LENGTH || Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) {        return tag;      }      return tag.substring(0, MAX_TAG_LENGTH);    }//获取tag信息。判断是否有tag信息，如果没有则创建一个。    @Override final String getTag() {      String tag = super.getTag();      if (tag != null) {        return tag;      }      // DO NOT switch this to Thread.getCurrentThread().getStackTrace(). The test will pass      // because Robolectric runs them on the JVM but on Android the elements are different.      StackTraceElement[] stackTrace = new Throwable().getStackTrace();      if (stackTrace.length &lt;= CALL_STACK_INDEX) {        throw new IllegalStateException(            &quot;Synthetic stacktrace didn&#39;t have enough elements: are you using proguard?&quot;);      }      return createStackElementTag(stackTrace[CALL_STACK_INDEX]);    }    /**     * Break up {@code message} into maximum-length chunks (if needed) and send to either     * {@link Log#println(int, String, String) Log.println()} or     * {@link Log#wtf(String, String) Log.wtf()} for logging.     *     * {@inheritDoc}     */    @Override protected void log(int priority, String tag, @NotNull String message, Throwable t) {      if (message.length() &lt; MAX_LOG_LENGTH) {        if (priority == Log.ASSERT) {          Log.wtf(tag, message);        } else {          Log.println(priority, tag, message);        }        return;      }//如果过长则分开打印      // Split by line, then ensure each line can fit into Log&#39;s maximum length.      for (int i = 0, length = message.length(); i &lt; length; i++) {        int newline = message.indexOf(&#39;\n&#39;, i);        newline = newline != -1 ? newline : length;        do {          int end = Math.min(newline, i + MAX_LOG_LENGTH);          String part = message.substring(i, end);          if (priority == Log.ASSERT) {            Log.wtf(tag, part);          } else {            Log.println(priority, tag, part);          }          i = end;        } while (i &lt; newline);      }    }  }</code></pre><p>DebugTree类提供了一个控制台打印的方式。可以通过集成该类修改<code>log(int priority, String tag, @NotNull String message, Throwable t)</code>来更改输出方式。log方法里面会判断message长度是否超长了。如果超了则分开打印。getTag主要是做了两件事，一个是获取是否有设置的tag值，如果没有则创建一个tag值。这里巧妙用到了<code>Throwable().getStackTrace()</code>里面的StackTraceElement[] 来获取该调用的类的类名。如果是加了混淆可能是调用不出来，这点要注意了。最好设置debug开关，或者自己填写tag信息。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列原理</title>
      <link href="/2020/01/05/handler/"/>
      <url>/2020/01/05/handler/</url>
      
        <content type="html"><![CDATA[<p>文章将带你理解 Looper、Handler、Message三者的关系。</p><h1 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h1><h2 id="延时应用"><a href="#延时应用" class="headerlink" title="延时应用"></a>延时应用</h2><p>定时器应用</p><pre><code class="java">//一个定时器    private Handler handler = new Handler();      private Runnable myRunnable= new Runnable() {            public void run() {              if (run) {                  handler.postDelayed(this, 1000);                  count++;              }              tvCounter.setText(&quot;Count: &quot; + count);          }      }; //然后在其他地方调用handler.post(myRunnable);handler.post(myRunnable,time);</code></pre><pre><code class="java">    new Thread(new Runnable() {            @Override            public void run() {                //在子线程post一个Runnable对象                handler.post(new Runnable() {                    @Override                    public void run() {                        //这里是消息处理的方法                        //这里运行在主线程。                    }                });            }        }).start();</code></pre><h2 id="一个线程发送消息，另外一个线程接收信息"><a href="#一个线程发送消息，另外一个线程接收信息" class="headerlink" title="一个线程发送消息，另外一个线程接收信息"></a>一个线程发送消息，另外一个线程接收信息</h2><pre><code class="java">   //在主线程创建一个Handler对象。    //重写Handler的handleMessage方法，这个就是接收并处理消息的方法。    Handler handler = new Handler(){        @Override        public void handleMessage(Message msg) {            //msg就是子线程发送过来的消息。        }    };    //开启一个子线程    new Thread(new Runnable() {            @Override            public void run() {                //在子线程发送一个消息。                Message msg = new Message();                handler.sendMessage(msg);            }        }).start();</code></pre><pre><code class="java"> //声明Handler；    Handler handler;    new Thread(new Runnable() {        @Override        public void run() {        //创建当前线程的Looper            Looper.prepare();            //在子线程创建handler对象            handler = new Handler() {                @Override                public void handleMessage(Message msg) {                //这里是消息处理，它是运行在子线程的                }           };           //开启Looper的消息轮询           Looper.loop();       }   }).start();   mBanner.setOnClickListener(new View.OnClickListener() {       @Override       public void onClick(View v) {       //在主线程发送一个消息到子线程           Message msg = new Message();           handler.sendMessage(msg);       }   });//退出轮询    Looper.myLooper().quit();    Looper.myLooper().quitSafely();</code></pre><h2 id="获取主线程"><a href="#获取主线程" class="headerlink" title="获取主线程"></a>获取主线程</h2><p>Looper.getMainLooper()是获取主线程消息队列。</p><pre><code class="java">   new Thread(new Runnable() {        @Override        public void run() {            //获取主线程的Looper            Looper looper = Looper.getMainLooper();            //用主线程的Looper创建Handler            handler = new Handler(looper) {                @Override                public void handleMessage(Message msg) {                //这里是运行在主线程的                }            };        }    }).start();</code></pre><p>取消某个消息</p><pre><code class="java">handler.removeCallbacksAndMessages(null); //取消所有的回调方法和message</code></pre><h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>\frameworks\base\core\java\android\os\Message.java</p><pre><code class="java">public final class Message implements Parcelable { /**     * User-defined message code so that the recipient can identify     * what this message is about. Each {@link Handler} has its own name-space     * for message codes, so you do not need to worry about yours conflicting     * with other handlers.     */    public int what;    /**     * arg1 and arg2 are lower-cost alternatives to using     * {@link #setData(Bundle) setData()} if you only need to store a     * few integer values.     */    public int arg1;    /**     * arg1 and arg2 are lower-cost alternatives to using     * {@link #setData(Bundle) setData()} if you only need to store a     * few integer values.     */    public int arg2;    /**     * An arbitrary object to send to the recipient.  When using     * {@link Messenger} to send the message across processes this can only     * be non-null if it contains a Parcelable of a framework class (not one     * implemented by the application).   For other data transfer use     * {@link #setData}.     *     * &lt;p&gt;Note that Parcelable objects here are not supported prior to     * the {@link android.os.Build.VERSION_CODES#FROYO} release.     */    public Object obj;    /**     * Optional Messenger where replies to this message can be sent.  The     * semantics of exactly how this is used are up to the sender and     * receiver.     */    public Messenger replyTo;    /**     * Optional field indicating the uid that sent the message.  This is     * only valid for messages posted by a {@link Messenger}; otherwise,     * it will be -1.     */    public int sendingUid = -1;    /** If set message is in use.     * This flag is set when the message is enqueued and remains set while it     * is delivered and afterwards when it is recycled.  The flag is only cleared     * when a new message is created or obtained since that is the only time that     * applications are allowed to modify the contents of the message.     *     * It is an error to attempt to enqueue or recycle a message that is already in use.     */    /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;    /** If set message is asynchronous */    /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;    /** Flags to clear in the copyFrom method */    /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;    /*package*/ int flags;    /*package*/ long when;    /*package*/ Bundle data;    /*package*/ Handler target;    /*package*/ Runnable callback;    // sometimes we store linked lists of these things    /*package*/ Message next;    private static final Object sPoolSync = new Object();    private static Message sPool;    private static int sPoolSize = 0;    private static final int MAX_POOL_SIZE = 50;    private static boolean gCheckRecycle = true;    public static Message obtain() {        synchronized (sPoolSync) {            //如果消息池里面有空闲的消息可以用，则用消息池里面的。            if (sPool != null) {                //当前这条信息取自消息池里面的复用                Message m = sPool;                //取出消息池的下一条未用信息                sPool = m.next;                //当前这条链路掐断                m.next = null;                m.flags = 0; // clear in-use flag                //消息池内信息减1                sPoolSize--;                return m;            }        }        return new Message();    }    /**     * Same as {@link #obtain()}, but copies the values of an existing     * message (including its target) into the new one.     * @param orig Original message to copy.     * @return A Message object from the global pool.     */    public static Message obtain(Message orig) {        Message m = obtain();        m.what = orig.what;        m.arg1 = orig.arg1;        m.arg2 = orig.arg2;        m.obj = orig.obj;        m.replyTo = orig.replyTo;        m.sendingUid = orig.sendingUid;        if (orig.data != null) {            m.data = new Bundle(orig.data);        }        m.target = orig.target;        m.callback = orig.callback;        return m;    }    /**     * Same as {@link #obtain()}, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned.     * @param h  Handler to assign to the returned Message object&#39;s &lt;em&gt;target&lt;/em&gt; member.     * @return A Message object from the global pool.     */    public static Message obtain(Handler h) {        Message m = obtain();        m.target = h;        return m;    }    /**     * Same as {@link #obtain(Handler)}, but assigns a callback Runnable on     * the Message that is returned.     * @param h  Handler to assign to the returned Message object&#39;s &lt;em&gt;target&lt;/em&gt; member.     * @param callback Runnable that will execute when the message is handled.     * @return A Message object from the global pool.     */    public static Message obtain(Handler h, Runnable callback) {        Message m = obtain();        m.target = h;        m.callback = callback;        return m;    }        /**     * Same as {@link #obtain()}, but sets the values for both &lt;em&gt;target&lt;/em&gt; and     * &lt;em&gt;what&lt;/em&gt; members on the Message.     * @param h  Value to assign to the &lt;em&gt;target&lt;/em&gt; member.     * @param what  Value to assign to the &lt;em&gt;what&lt;/em&gt; member.     * @return A Message object from the global pool.     */    public static Message obtain(Handler h, int what) {        Message m = obtain();        m.target = h;        m.what = what;        return m;    }    /**     * Return a Message instance to the global pool.     * &lt;p&gt;     * You MUST NOT touch the Message after calling this function because it has     * effectively been freed.  It is an error to recycle a message that is currently     * enqueued or that is in the process of being delivered to a Handler.     * &lt;/p&gt;     */     //回收消息    public void recycle() {        if (isInUse()) {            if (gCheckRecycle) {                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;                        + &quot;is still in use.&quot;);            }            return;        }        recycleUnchecked();    }    /**     * Recycles a Message that may be in-use.     * Used internally by the MessageQueue and Looper when disposing of queued Messages.     */    void recycleUnchecked() {        // Mark the message as in use while it remains in the recycled object pool.        // Clear out all other details.        flags = FLAG_IN_USE;        what = 0;        arg1 = 0;        arg2 = 0;        obj = null;        replyTo = null;        sendingUid = -1;        when = 0;        target = null;        callback = null;        data = null;        synchronized (sPoolSync) {            //消息池里面只保留MAX_POOL_SIZE条空闲的信息，这些信息等待下次使用。            //如果实际消息池里面的数量还不够50条，则回收这一条信息,            if (sPoolSize &lt; MAX_POOL_SIZE) {                //当前这条信息连接好消息池里面空闲信息头                next = sPool;                //回收好当前这条信息                sPool = this;                //消息池内消息数量加1                sPoolSize++;            }        }    }    ......//还有set/get参数、序列化等等方法就不罗列了。}</code></pre><p>Message主要的实例属性是what ，arg1 ，arg2 ，obj,target，callback，next。what是主要是识别身份的，arg1，arg2是int参数，obj是传递的对象的，一般是作为令牌（token）来用，target是所用的handler。callback是Runnable， 需要的时候Run里面的任务。next是下一条message。message之间连成链式连接，这就是消息队列。消息队列是单向链表。<br>可以看到<code>public static Message obtain()</code>里面会根据原来有没有message来创建，如果有，拿出消息池里面的message出来用，sPoolSize–，如果没有则新建一条。message线程池的大小是50条，MAX_POOL_SIZE = 50。消息池实质是回收消息池，消息数目是可以超过50条的，只是消息池会回收最多50条用完的消息来存着备用。<br>obtain有好几个重载。</p><pre><code class="java">public static Message obtain(Handler h)public static Message obtain(Handler h, Runnable callback)public static Message obtain(Handler h, int what)public static Message obtain(Handler h, int what, Object obj) public static Message obtain(Handler h, int what, int arg1, int arg2)public static Message obtain(Handler h, int what, int arg1, int arg2, Object obj)</code></pre><p>可以根据自己需要创建不同参数的message。<br>recycle() 是回收message用的。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p>当用post发送Runnable 时候，它们是进行下面操作。<br>\frameworks\base\core\java\android\os\Handler.java</p><pre><code class="java">    /**     * Causes the Runnable r to be added to the message queue.     * The runnable will be run on the thread to which this handler is      * attached.      *       * @param r The Runnable that will be executed.     *      * @return Returns true if the Runnable was successfully placed in to the      *         message queue.  Returns false on failure, usually because the     *         looper processing the message queue is exiting.     */    public final boolean post(Runnable r)    {        //设置定时为0，用getPostMessage新建了一message       return  sendMessageDelayed(getPostMessage(r), 0);    }    //这里新建了一个Mssage,然后把Runnable 放进去。    private static Message getPostMessage(Runnable r) {        Message m = Message.obtain();        m.callback = r;        return m;    }    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {        //获取当前消息队列         MessageQueue queue = mQueue;         //如果当前消息队列为空，则失败        if (queue == null) {            RuntimeException e = new RuntimeException(                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);            Log.w(&quot;Looper&quot;, e.getMessage(), e);            return false;        }        //处理消息队列里面的消息。        return enqueueMessage(queue, msg, uptimeMillis);    }    //处理消息队列里面的消息。    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {        msg.target = this;        if (mAsynchronous) {            msg.setAsynchronous(true);        }        //调用消息队列里面的enqueueMessage，传进去消息和延时时间，这个实例里面传的是0.        return queue.enqueueMessage(msg, uptimeMillis);    }</code></pre><p>消息队列处理<br>\frameworks\base\core\java\android\os\MessageQueue.java</p><pre><code class="java">    //消息排队，主要是刷选将要执行的消息，并把新消息入队。    boolean enqueueMessage(Message msg, long when) {        //检查handler是否有        if (msg.target == null) {            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);        }        if (msg.isInUse()) {            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);        }        //异步操作        synchronized (this) {            //表示当前队列是否处于正在退出状态            if (mQuitting) {                IllegalStateException e = new IllegalStateException(                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);                Log.w(TAG, e.getMessage(), e);                msg.recycle();                return false;            }            msg.markInUse();            //设置延时时间            msg.when = when;            //    Message mMessages;这个是链头，也相当于指针的作用了。            Message p = mMessages;            boolean needWake;            //p == null 意味着到尾了。when == 0是立刻执行。when &lt; p.when是比下一个message要早时间执行。            //此时消息队列是有序排列的，按时间先后顺序。            if (p == null || when == 0 || when &lt; p.when) {                // New head, wake up the event queue if blocked.                //唤醒执行。设置当前消息为要执行消息。                msg.next = p;                mMessages = msg;                needWake = mBlocked;            } else {//当前消息不是要将要执行消息。有其他消息需要先执行                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake                // up the event queue unless there is a barrier at the head of the queue                // and the message is the earliest asynchronous message in the queue.               //Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.               //private boolean mBlocked;                    needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();                Message prev;                //这个主要是要找msge插入到队列的位置。                for (;;) {                    //用prev来指向当前队列的某个mssage，如果找到这个message将排在msg之前，p找下一个mssage                    prev = p;                    //找下链条里面的一个mssage，直到找完整个队列或者找到执行时间要比当前时间要长的。                    p = p.next;                    if (p == null || when &lt; p.when) {                        break;                    }                    if (needWake &amp;&amp; p.isAsynchronous()) {                        needWake = false;                    }                }                //插入队列适合的位置                msg.next = p; // invariant: p == prev.next                prev.next = msg;            }            // We can assume mPtr != 0 because mQuitting is false.            //这里看是否唤醒线程循环，这里用到epoll技术            if (needWake) {                nativeWake(mPtr);            }        }        return true;    }</code></pre><p>上面的操作已经把消息打入队列里面了。此时队列是有序排列的。</p><h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><p>发送消息<br>\frameworks\base\core\java\android\os\Handler.java</p><pre><code class="java">    /**     * Pushes a message onto the end of the message queue after all pending messages     * before the current time. It will be received in {@link #handleMessage},     * in the thread attached to this handler.     *       * @return Returns true if the message was successfully placed in to the      *         message queue.  Returns false on failure, usually because the     *         looper processing the message queue is exiting.     */    public final boolean sendMessage(Message msg)    {        //设置为0是立刻执行        return sendMessageDelayed(msg, 0);    }    /**     * Enqueue a message into the message queue after all pending messages     * before (current time + delayMillis). You will receive it in     * {@link #handleMessage}, in the thread attached to this handler.     *       * @return Returns true if the message was successfully placed in to the      *         message queue.  Returns false on failure, usually because the     *         looper processing the message queue is exiting.  Note that a     *         result of true does not mean the message will be processed -- if     *         the looper is quit before the delivery time of the message     *         occurs then the message will be dropped.     */    public final boolean sendMessageDelayed(Message msg, long delayMillis)    {        if (delayMillis &lt; 0) {            delayMillis = 0;        }        //SystemClock.uptimeMillis()表示系统开机到当前的时间总数，单位是毫秒，        //但是，当系统进入深度睡眠（CPU休眠、屏幕休眠、设备等待外部输入）时间就会停止，        //但是不会受到时钟缩放、空闲或者其他节能机制的影响。        //这里是延时加当前系统时间，表示未来要执行的时间点。        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);    }    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {        MessageQueue queue = mQueue;        if (queue == null) {            RuntimeException e = new RuntimeException(                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);            Log.w(&quot;Looper&quot;, e.getMessage(), e);            return false;        }        //消息队列排队        return enqueueMessage(queue, msg, uptimeMillis);    }    //把消息放到队列里面    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {        msg.target = this;        if (mAsynchronous) {            msg.setAsynchronous(true);        }        return queue.enqueueMessage(msg, uptimeMillis);    }</code></pre><p>queue.enqueueMessage是根据放进去的消息来排列，上面已经说了原理。</p><h3 id="postDelayed"><a href="#postDelayed" class="headerlink" title="postDelayed"></a>postDelayed</h3><p>基本原理和sendMessage一样</p><p>\frameworks\base\core\java\android\os\Handler.java</p><pre><code class="java">    public final boolean postDelayed(Runnable r, long delayMillis)    {        //生成一个新的mssage，设置好延时毫秒        return sendMessageDelayed(getPostMessage(r), delayMillis);    }    public final boolean sendMessageDelayed(Message msg, long delayMillis)    {        if (delayMillis &lt; 0) {            delayMillis = 0;        }        //系统启动时间加要延时时间        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);    }    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {        MessageQueue queue = mQueue;        if (queue == null) {            RuntimeException e = new RuntimeException(                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);            Log.w(&quot;Looper&quot;, e.getMessage(), e);            return false;        }        //加入消息队列里面        return enqueueMessage(queue, msg, uptimeMillis);    }    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {        msg.target = this;        if (mAsynchronous) {            msg.setAsynchronous(true);        }        return queue.enqueueMessage(msg, uptimeMillis);    }</code></pre><p>延时在消息从系统启动时间算起，看延时到哪个点，然后放到消息队列里面。</p><h3 id="removeCallbacks"><a href="#removeCallbacks" class="headerlink" title="removeCallbacks"></a>removeCallbacks</h3><p>移除Callback<br>\frameworks\base\core\java\android\os\Handler.java</p><pre><code class="java">    /**     * Remove any pending posts of Runnable r that are in the message queue.     */    public final void removeCallbacks(Runnable r)    {        mQueue.removeMessages(this, r, null);    }</code></pre><p>从消息队列里匹对消息然后移除该消息<br>\frameworks\base\core\java\android\os\MessageQueue.java</p><pre><code class="java">    void removeMessages(Handler h, Runnable r, Object object) {        if (h == null || r == null) {            return;        }        synchronized (this) {            //mMessages是消息队列的队首            Message p = mMessages;            // Remove all messages at front.            //这里用循环来匹配消息内容，如果找到了，则把该条massage移除。            //从队首开始删除，如果删除了队首就指向接下来的元素。            while (p != null &amp;&amp; p.target == h &amp;&amp; p.callback == r                   &amp;&amp; (object == null || p.obj == object)) {                   //令mMessages为下一个mssage                 Message n = p.next;                mMessages = n;                //这里回收消息                p.recycleUnchecked();                p = n;            }            // Remove all messages after front.            //如果不为结尾继续循环，移除找到的Message            while (p != null) {                Message n = p.next;                //如果下一条不是结尾还是有的话继续处理                if (n != null) {                    //匹配当前消息                    if (n.target == h &amp;&amp; n.callback == r                        &amp;&amp; (object == null || n.obj == object)) {                        Message nn = n.next;                        n.recycleUnchecked();                        p.next = nn;                        continue;                    }                }                p = n;            }        }    }</code></pre><p><code>handler.removeCallbacksAndMessages(null);</code>是用来清空消息队列的，此时匹对的消息的obj都是为null。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>经过handler把消息压进了消息队列，需要一个循环逐一拿出来用，这个循环是Looper。在调用中用<code>Looper.loop();</code>来开启。</p><pre><code class="java"> //声明Handler；    Handler handler;    new Thread(new Runnable() {        @Override        public void run() {        //创建当前线程的Looper            Looper.prepare();            //在子线程创建handler对象            handler = new Handler() {                @Override                public void handleMessage(Message msg) {                //这里是消息处理，它是运行在子线程的                }           };           //开启Looper的消息轮询           Looper.loop();       }   }).start();</code></pre><p>\frameworks\base\core\java\android\os\Looper.java</p><pre><code class="java">public final class Looper {    /*     * API Implementation Note:     *     * This class contains the code required to set up and manage an event loop     * based on MessageQueue.  APIs that affect the state of the queue should be     * defined on MessageQueue or Handler rather than on Looper itself.  For example,     * idle handlers and sync barriers are defined on the queue whereas preparing the     * thread, looping, and quitting are defined on the looper.     */    private static final String TAG = &quot;Looper&quot;;    // sThreadLocal.get() will return null unless you&#39;ve called prepare().    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();    //主线程调用的Looper    private static Looper sMainLooper;  // guarded by Looper.class    final MessageQueue mQueue;    final Thread mThread;    private Printer mLogging;    private long mTraceTag;    /* If set, the looper will show a warning log if a message dispatch takes longer than time. */    private long mSlowDispatchThresholdMs;     /** Initialize the current thread as a looper.      * This gives you a chance to create handlers that then reference      * this looper, before actually starting the loop. Be sure to call      * {@link #loop()} after calling this method, and end it by calling      * {@link #quit()}.      */      //线程里面构建一个新的looper，Looper.prepare();每一个Looper对象会和一个线程关联       //Looper对象创建时会创建一个MessageQueue,一般其他线程要这个looper要调用Looper.prepare()    public static void prepare() {        prepare(true);    }    private static void prepare(boolean quitAllowed) {        if (sThreadLocal.get() != null) {            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);        }        sThreadLocal.set(new Looper(quitAllowed));    }    /**     * Initialize the current thread as a looper, marking it as an     * application&#39;s main looper. The main looper for your application     * is created by the Android environment, so you should never need     * to call this function yourself.  See also: {@link #prepare()}     */    //这个主线程的looper，一般是系统来调用的    public static void prepareMainLooper() {        prepare(false);        synchronized (Looper.class) {            if (sMainLooper != null) {                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);            }            sMainLooper = myLooper();        }    }    /**     * Returns the application&#39;s main looper, which lives in the main thread of the application.     */     //这个是获取主线程的Looper，UI线程的大循环是这里取得     //如果你想建立一个UI更新的handler，可以这么操作     //Handler mhandler = new Handler(Looper.getMainLooper);    public static Looper getMainLooper() {        synchronized (Looper.class) {            return sMainLooper;        }    }    /**     * Run the message queue in this thread. Be sure to call     * {@link #quit()} to end the loop.     */     //Looper.loop就是这个循环    public static void loop() {        //sThreadLocal里面获取当前的ThreadLocal，其实是Looper对象。        final Looper me = myLooper();        if (me == null) {            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);        }        //获取当前Looper的消息队列        final MessageQueue queue = me.mQueue;        // Make sure the identity of this thread is that of the local process,        // and keep track of what that identity token actually is.        Binder.clearCallingIdentity();        final long ident = Binder.clearCallingIdentity();        //死循环        for (;;) {            //查找下一条消息,消息队列里面保存有mMessages，这个是链头            Message msg = queue.next(); // might block            if (msg == null) {                // No message indicates that the message queue is quitting.                //如果没有消息则打断死循环跳出去                return;            }            // This must be in a local variable, in case a UI event sets the logger            final Printer logging = me.mLogging;            if (logging != null) {                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +                        msg.callback + &quot;: &quot; + msg.what);            }            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;            final long traceTag = me.mTraceTag;            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));            }            //SystemClock.uptimeMillis() 从开机到现在的毫秒数（手机睡眠的时间不包括在内）            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();            final long end;            try {                //这里调用的是handler里面的dispatchMessage(Message msg)方法，                //它将会调用我们自己定义的handleMessage方法。                msg.target.dispatchMessage(msg);                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();            } finally {                if (traceTag != 0) {                    Trace.traceEnd(traceTag);                }            }            //根据需要算时间差            if (slowDispatchThresholdMs &gt; 0) {                final long time = end - start;                if (time &gt; slowDispatchThresholdMs) {                    Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;                            + Thread.currentThread().getName() + &quot;, h=&quot; +                            msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);                }            }            if (logging != null) {                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);            }            // Make sure that during the course of dispatching the            // identity of the thread wasn&#39;t corrupted.            final long newIdent = Binder.clearCallingIdentity();            if (ident != newIdent) {                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;                        + Long.toHexString(ident) + &quot; to 0x&quot;                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;                        + msg.target.getClass().getName() + &quot; &quot;                        + msg.callback + &quot; what=&quot; + msg.what);            }            //消息回收，这里的消息池内会回收消息。            msg.recycleUnchecked();        }    }    /**     * Return the Looper object associated with the current thread.  Returns     * null if the calling thread is not associated with a Looper.     */     //获取当前thread的threadload    public static @Nullable Looper myLooper() {        return sThreadLocal.get();    }    /**     * Return the {@link MessageQueue} object associated with the current     * thread.  This must be called from a thread running a Looper, or a     * NullPointerException will be thrown.     */     //获取threadload里面的消息队列    public static @NonNull MessageQueue myQueue() {        return myLooper().mQueue;    }    private Looper(boolean quitAllowed) {        mQueue = new MessageQueue(quitAllowed);        mThread = Thread.currentThread();    }    /**     * Returns true if the current thread is this looper&#39;s thread.     */    public boolean isCurrentThread() {        return Thread.currentThread() == mThread;    }    ......}</code></pre><p>大致的处理过程是获取当前线程的looper，然后获取looper里面的消息队列，然后一个个处理消息队列里面的消息，处理完就回收消息。</p><p>loop()里面的msg.target.dispatchMessage(msg);是调用了我们定义消息处理动作了。dispatchMessage里面是调用handleCallback或者handleMessage。dispatchMessage是Handler里面的方法。<br>\frameworks\base\core\java\android\os\Handler.java</p><pre><code class="java">    /**     * Handle system messages here.     */    public void dispatchMessage(Message msg) {        //判断是否为空        if (msg.callback != null) {            handleCallback(msg);        } else {            //这里检查Callback 有没有被实现，如果有则调用改接口的handleMessage            if (mCallback != null) {                if (mCallback.handleMessage(msg)) {                    return;                }            }            //这一步是调用我们定义的内容            handleMessage(msg);        }    }    //如果有callback则run，callback是一个Runnable    private static void handleCallback(Message message) {        message.callback.run();    }//handleMessage是我们定义的处理信息的动作了。    /**     * Callback interface you can use when instantiating a Handler to avoid     * having to implement your own subclass of Handler.     *     * @param msg A {@link android.os.Message Message} object     * @return True if no further handling is desired     */    public interface Callback {        public boolean handleMessage(Message msg);    }    /**     * Subclasses must implement this to receive messages.     */    public void handleMessage(Message msg) {    }</code></pre><p>看下<code>Message msg = queue.next();</code>里面执行了什么。<br>\frameworks\base\core\java\android\os\MessageQueue.java</p><pre><code class="java">public final class MessageQueue {    Message mMessages;    ......    Message next() {        // Return here if the message loop has already quit and been disposed.        // This can happen if the application tries to restart a looper after quit        // which is not supported.        final long ptr = mPtr;        if (ptr == 0) {            return null;        }        int pendingIdleHandlerCount = -1; // -1 only during first iteration        int nextPollTimeoutMillis = 0;        for (;;) {            //这个nextPollTimeoutMillis 是上一次消息处理适合设置的下一次唤醒时间，没到时间就休眠            if (nextPollTimeoutMillis != 0) {                Binder.flushPendingCommands();            }            //阻塞            nativePollOnce(ptr, nextPollTimeoutMillis);            synchronized (this) {                // Try to retrieve the next message.  Return if found.                //这里主要是检索吓一条mssage。如果找到就返回。                //获取当前的时间。这个时间是系统开机时间，用毫秒表示。                final long now = SystemClock.uptimeMillis();                Message prevMsg = null;                //获取消息队列的头                Message msg = mMessages;                //如果handler没写好就一直找到下一个设置好target的message为止。                if (msg != null &amp;&amp; msg.target == null) {                    // Stalled by a barrier.  Find the next asynchronous message in the queue.                    do {                        prevMsg = msg;                        msg = msg.next;                    } while (msg != null &amp;&amp; !msg.isAsynchronous());                }                if (msg != null) {                    //看下时间到了没。                    //注意你之前设定的定时信息在这里其作用了。没到点不执行。                    if (now &lt; msg.when) {                        // Next message is not ready.  Set a timeout to wake up when it is ready.                        //下一条信息还没到时间执行。                        //设置下一次执行的唤醒时间                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                    } else {                        // Got a message.                        //下一条信息到时间执行了，取出来。                        mBlocked = false;                        //如果该条信息还有前一条信息则设置好前一条信息的链路                        if (prevMsg != null) {                            prevMsg.next = msg.next;                        } else {                            //设置队列头为下一条信息                            mMessages = msg.next;                        }                        //断开链路，单独取出来。                        msg.next = null;                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);                        msg.markInUse();                        return msg;                    }                } else {                    // No more messages.                    //没有消息了                    nextPollTimeoutMillis = -1;                }                //消息都已经执行，并清空了。执行下面的流程。                //其实是设置epoll的唤醒时间                // Process the quit message now that all pending messages have been handled.                if (mQuitting) {                    dispose();                    return null;                }                //IdleHandler 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情                //（譬如 UI 线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。                // If first time idle, then get the number of idlers to run.                // Idle handles only run if the queue is empty or if the first message                // in the queue (possibly a barrier) is due to be handled in the future.                if (pendingIdleHandlerCount &lt; 0                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {                    pendingIdleHandlerCount = mIdleHandlers.size();                }                if (pendingIdleHandlerCount &lt;= 0) {                    // No idle handlers to run.  Loop and wait some more.                    mBlocked = true;                    continue;                }                if (mPendingIdleHandlers == null) {                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];                }                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);            }            // Run the idle handlers.            // We only ever reach this code block during the first iteration.            //循环遍历所有IdleHandler            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {                final IdleHandler idler = mPendingIdleHandlers[i];                mPendingIdleHandlers[i] = null; // release the reference to the handler                boolean keep = false;                try {                    keep = idler.queueIdle();                } catch (Throwable t) {                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);                }                if (!keep) {                    synchronized (this) {                        mIdleHandlers.remove(idler);                    }                }            }            // Reset the idle handler count to 0 so we do not run them again.            pendingIdleHandlerCount = 0;            // While calling an idle handler, a new message could have been delivered            // so go back and look again for a pending message without waiting.            nextPollTimeoutMillis = 0;        }    }    ...... }</code></pre><p>MessageQueue.mMessages-&gt;( Message并且Message.next)-&gt; ( Message并且Message.next)-&gt;…–&gt;null 构成一个单向链表。<code>Message msg = queue.next();</code>是拿出下一条message出来，如果设置了定时，没到时间就会拿出来。拿出来后通过<code>msg.target.dispatchMessage(msg);</code>来执行。这个looper是个循环，有消息就处理，没消息就阻塞，通过epoll机制来调整运行状态。在塞信息进入消息队列适合会判断是否唤醒循环<code>nativeWake(mPtr);</code></p><p>next里面的阻塞代码是下面这个。阻塞是发生在nativePollOnce方法，在native层使用了epoll机制来等待消息。</p><pre><code class="java">//private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/for (;;) {    if (nextPollTimeoutMillis != 0) {        Binder.flushPendingCommands();    }    nativePollOnce(ptr, nextPollTimeoutMillis);    //...}</code></pre><p>退出消息队列</p><p>\frameworks\base\core\java\android\os\Looper.java</p><pre><code class="java">    /**     * Quits the looper.     * &lt;p&gt;     * Causes the {@link #loop} method to terminate without processing any     * more messages in the message queue.     * &lt;/p&gt;&lt;p&gt;     * Any attempt to post messages to the queue after the looper is asked to quit will fail.     * For example, the {@link Handler#sendMessage(Message)} method will return false.     * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt;     * Using this method may be unsafe because some messages may not be delivered     * before the looper terminates.  Consider using {@link #quitSafely} instead to ensure     * that all pending work is completed in an orderly manner.     * &lt;/p&gt;     *     * @see #quitSafely     */    public void quit() {        mQueue.quit(false);    }    /**     * Quits the looper safely.     * &lt;p&gt;     * Causes the {@link #loop} method to terminate as soon as all remaining messages     * in the message queue that are already due to be delivered have been handled.     * However pending delayed messages with due times in the future will not be     * delivered before the loop terminates.     * &lt;/p&gt;&lt;p&gt;     * Any attempt to post messages to the queue after the looper is asked to quit will fail.     * For example, the {@link Handler#sendMessage(Message)} method will return false.     * &lt;/p&gt;     */    public void quitSafely() {        mQueue.quit(true);    }</code></pre><p>\frameworks\base\core\java\android\os\MessageQueue.java</p><pre><code class="java">    void quit(boolean safe) {        if (!mQuitAllowed) {            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);        }        synchronized (this) {            if (mQuitting) {                return;            }            mQuitting = true;            if (safe) {                removeAllFutureMessagesLocked();            } else {                removeAllMessagesLocked();            }            // We can assume mPtr != 0 because mQuitting was previously false.            nativeWake(mPtr);        }    }//可以从代码看出退出队列会把队列清空    private void removeAllMessagesLocked() {        Message p = mMessages;        while (p != null) {            Message n = p.next;            p.recycleUnchecked();            p = n;        }        mMessages = null;    }    private void removeAllFutureMessagesLocked() {        final long now = SystemClock.uptimeMillis();        Message p = mMessages;        if (p != null) {            if (p.when &gt; now) {                removeAllMessagesLocked();            } else {                Message n;                //如果队列头不是未来要执行的message的话，则继续找，找到为止。然后再回收那些未来某个点执行的message。                for (;;) {                    n = p.next;                    if (n == null) {                        return;                    }                    if (n.when &gt; now) {                        break;                    }                    //在链表里面找到不是立即执行的message，然后断开，再回收那些未来要执行的message                    p = n;                }                //这里是为了链表断开那些定时和没定时的message                p.next = null;                //定时执行的message将被回收。                do {                    p = n;                    n = p.next;                    p.recycleUnchecked();                } while (n != null);            }        }    }</code></pre><p>looper里面的quit()或quitSafely()可以退出消息队列，从代码看出退出队列会把队列清空。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntentService耗时操作的原理</title>
      <link href="/2020/01/05/Intentservice/"/>
      <url>/2020/01/05/Intentservice/</url>
      
        <content type="html"><![CDATA[<p>由于Service和Broadcast都是运行在主线程中，所以在这两个里面我们无法做一些长时间的耗时操作，要执行耗时操作可以用异步线程AsyncTask或者IntentServie。IntentServie的好处是调用玩后会自己关闭service。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>调用基本是重写IntentService，然后生成intent，startService。</p><pre><code class="java">public class MyIntentService extends IntentService {    //必须创建构造方法    //因为IntentService里面已经有个一个构造方法了，构建的时候jvm不会再构造一个构造方法了。    //你继承IntentService如果不添加构造方法将没有构造方法。jvm会报错。    //java.lang.InstantiationException: java.lang.Class&lt;***.MyService&gt; has no zero argument constructor    public MyIntentService () {        super(&quot;&quot;);    }      //实现你要做的内容    @Override    protected void onHandleIntent(@Nullable Intent intent) {        System.out.println(&quot;工作线程是: &quot;+Thread.currentThread().getName());        String task = intent.getStringExtra(&quot;task&quot;);        System.out.println(&quot;任务是 :&quot;+task);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}    //在Manifest.xml中注册服务    //调用方式。        Intent intent = new Intent(this,MyIntentService .class);        intent.putExtra(&quot;task&quot;,&quot;播放音乐&quot;);        startService(intent);</code></pre><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>IntentService里面可以执行耗时操作，下面看下它是怎么实现的。</p><pre><code class="java">package android.app;import android.annotation.WorkerThread;import android.annotation.Nullable;import android.content.Intent;import android.os.Handler;import android.os.HandlerThread;import android.os.IBinder;import android.os.Looper;import android.os.Message;public abstract class IntentService extends Service {    private volatile Looper mServiceLooper;    private volatile ServiceHandler mServiceHandler;    private String mName;    private boolean mRedelivery;    private final class ServiceHandler extends Handler {        public ServiceHandler(Looper looper) {            super(looper);        }        @Override        public void handleMessage(Message msg) {            onHandleIntent((Intent)msg.obj);            stopSelf(msg.arg1);        }    }    public IntentService(String name) {        super();        mName = name;    }    public void setIntentRedelivery(boolean enabled) {        mRedelivery = enabled;    }    @Override    public void onCreate() {        // TODO: It would be nice to have an option to hold a partial wakelock        // during processing, and to have a static startService(Context, Intent)        // method that would launch the service &amp; hand off a wakelock.        super.onCreate();        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);        thread.start();        mServiceLooper = thread.getLooper();        mServiceHandler = new ServiceHandler(mServiceLooper);    }    @Override    public void onStart(@Nullable Intent intent, int startId) {        Message msg = mServiceHandler.obtainMessage();        msg.arg1 = startId;        msg.obj = intent;        mServiceHandler.sendMessage(msg);    }    /**     * You should not override this method for your IntentService. Instead,     * override {@link #onHandleIntent}, which the system calls when the IntentService     * receives a start request.     * @see android.app.Service#onStartCommand     */    @Override    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {        onStart(intent, startId);        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;    }    @Override    public void onDestroy() {        mServiceLooper.quit();    }    @Override    @Nullable    public IBinder onBind(Intent intent) {        return null;    }    @WorkerThread    protected abstract void onHandleIntent(@Nullable Intent intent);}</code></pre><p>IntentService 继承Service 。它里面主要是开了一个HandlerThread，执行耗时的操作的内容就在工作线程里面操作。</p><p>在onCreate的时候执时候，新建了一个HandlerThread</p><pre><code class="java">    public void onCreate() {        // TODO: It would be nice to have an option to hold a partial wakelock        // during processing, and to have a static startService(Context, Intent)        // method that would launch the service &amp; hand off a wakelock.        super.onCreate();        //新建线程        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);        thread.start();        //建立线程的Handler        mServiceLooper = thread.getLooper();        mServiceHandler = new ServiceHandler(mServiceLooper);    }</code></pre><p>HandlerThread继承了Thread，实现的run方法是建立一套安卓的异步消息队列的。</p><pre><code class="java">//HandlerThread的run方法。    @Override    public void run() {        mTid = Process.myTid();        Looper.prepare();        synchronized (this) {            mLooper = Looper.myLooper();            notifyAll();        }        Process.setThreadPriority(mPriority);        onLooperPrepared();        Looper.loop();        mTid = -1;    }</code></pre><p>在工作的时候，HandlerThread的onStart放就新建一个message放到handler里面。</p><pre><code class="java">    public void onStart(@Nullable Intent intent, int startId) {        Message msg = mServiceHandler.obtainMessage();        msg.arg1 = startId;        msg.obj = intent;        mServiceHandler.sendMessage(msg);    }</code></pre><p>Handler是另外定义的，对应到内部类是ServiceHandler 。</p><pre><code class="java">    private final class ServiceHandler extends Handler {        public ServiceHandler(Looper looper) {            super(looper);        }        @Override        public void handleMessage(Message msg) {            onHandleIntent((Intent)msg.obj);            stopSelf(msg.arg1);        }    }</code></pre><p>这里可以看出，执行handleMessage时候先执行<code>onHandleIntent((Intent)msg.obj);</code>,然后在执行<code>stopSelf(msg.arg1);</code>onHandleIntent是你自己定义的要执行的内容，stopSelf是结束service。也是就是说，执行完耗时操作后，会关掉service。</p><pre><code class="java">//Service 里面的    /**     * Stop the service, if it was previously started.  This is the same as     * calling {@link android.content.Context#stopService} for this particular service.     *       * @see #stopSelfResult(int)     */    public final void stopSelf() {        stopSelf(-1);    }    /**     * Old version of {@link #stopSelfResult} that doesn&#39;t return a result.     *       * @see #stopSelfResult     */    public final void stopSelf(int startId) {        if (mActivityManager == null) {            return;        }        try {            mActivityManager.stopServiceToken(                    new ComponentName(this, mClassName), mToken, startId);        } catch (RemoteException ex) {        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntentService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APK打包流程</title>
      <link href="/2020/01/05/apk-build-process/"/>
      <url>/2020/01/05/apk-build-process/</url>
      
        <content type="html"><![CDATA[<h2 id="APK结构"><a href="#APK结构" class="headerlink" title="APK结构"></a>APK结构</h2><p><img src="/images/apk%E7%BB%93%E6%9E%84.png" alt="apk结构"></p><p>apk是一个压缩包，里面有lib，META-INF，classes.dex，res，resources.arsc文件夹和文件。下面看看它们各自的作用。</p><table><thead><tr><th>名称</th><th>内容</th><th>详细</th></tr></thead><tbody><tr><td>lib</td><td>放的是so动态链接库</td><td>apk打包不需要处理的动态库</td></tr><tr><td>META-INF</td><td>签名文件夹</td><td>三个签名证书（MANIFEST.MF、CERT.SF、CERT.RSA）。MANIFEST.MF文件是对每个文件的SHA-256-Digest；CERT.SF是对每个文件的头3行进行SHA-256-Digest；CERT.RSA这个文件保存了签名和公钥证书。</td></tr><tr><td>classes.dex</td><td>执行文件</td><td>java编译后的Android可执行的dex文件</td></tr><tr><td>AndroidManifest.xml</td><td>声明文件</td><td>记录应用的名字、版本、权限、引用的库文件等信息</td></tr><tr><td>res</td><td>资源文件</td><td>有animator,anim,color,drawable,layout,menu，raw等文件夹</td></tr><tr><td>resources.arsc</td><td>编译后的二进制资源文件</td><td>记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。 这是一个索引文件。</td></tr></tbody></table><h2 id="初略流程"><a href="#初略流程" class="headerlink" title="初略流程"></a>初略流程</h2><p><img src="/images/build-process_2x.png" alt="build-process_2x"><br>谷歌官方给出的打包流程图。<br>先是把代码编译成Dex，然后是和资源文件整合成一个APK,再者加签名，最后出来之前还要用zipalign工具优化一下。</p><h2 id="细化流程"><a href="#细化流程" class="headerlink" title="细化流程"></a>细化流程</h2><p><img src="/images/%E7%BB%86%E5%8C%96%E7%9A%84%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png" alt="细化的打包流程"><br>上面这个图主要是有7个打包流程。</p><h3 id="1-打包资源文件，生成R-java文件"><a href="#1-打包资源文件，生成R-java文件" class="headerlink" title="1.打包资源文件，生成R.java文件"></a>1.打包资源文件，生成R.java文件</h3><p>aapt来打包res资源文件，生成R.java、resources.arsc和res文件。<br>* res目录</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>animator</td><td>放属性动画</td></tr><tr><td>anim</td><td>放补间动画</td></tr><tr><td>color</td><td>颜色资源</td></tr><tr><td>drawable</td><td>存放XML、Bitmap文件，或者.png, .9.png, .jpg, .gif文件等图像资源。打包过程中可能会被优化，比如色彩数可能会被优化，256色变8色。</td></tr><tr><td>layout</td><td>布局资源，布局的xml文件。</td></tr><tr><td>menu</td><td>应用程序菜单</td></tr><tr><td>raw</td><td>直接复制到设备中的任意文件。用参数是资源的ID调用，R.raw.somefilename。和assets 不同的是，raw下面不能有目录，而和assets可以有目录。</td></tr><tr><td>values</td><td>数值XML文件用来描述数组、颜色、尺寸、字符串和样式值等</td></tr><tr><td>xml</td><td>应用配置信息</td></tr></tbody></table><ul><li>R.java文件<br>R.java是我们在编写代码的时候会用到的，里面有静态内部类，资源等。</li><li>resources.arsc文件<br>resources.arsc这个文件记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。是一个资源索引表，在给定资源ID和设备配置信息的情况下能快速找到资源。</li></ul><h3 id="2-处理aidl文件，生成相应的Java文件"><a href="#2-处理aidl文件，生成相应的Java文件" class="headerlink" title="2.处理aidl文件，生成相应的Java文件"></a>2.处理aidl文件，生成相应的Java文件</h3><p>aidl（Android Interface Definition Language，Android接口描述语言），位于android-sdk/platform-tools目录下。aidl工具解析接口定义文件然后生成相应的Java代码接口供程序调用。如果项目没用到aidl则跳过这一步。</p><h3 id="3-编译项目源代码，生成class文件"><a href="#3-编译项目源代码，生成class文件" class="headerlink" title="3.编译项目源代码，生成class文件"></a>3.编译项目源代码，生成class文件</h3><p>Java Compiler阶段。项目中所有的Java代码，包括R.java和.aidl文件，都会变Java编译器（javac）编译成.class文件，生成的class文件位于工程中的bin/classes目录下。</p><h3 id="4-转换所有的class文件，生成classes-dex文件"><a href="#4-转换所有的class文件，生成classes-dex文件" class="headerlink" title="4.转换所有的class文件，生成classes.dex文件"></a>4.转换所有的class文件，生成classes.dex文件</h3><p>dex阶段。通过dx工具，将.class文件和第三方库中的.class文件处理生成classes.dex文件。该工具位于android-sdk/platform-tools 目录下。dx工具的主要工作是将Java字节码转成成Dalvik字节码、压缩常量池、消除冗余信息等。</p><h3 id="5-打包生成APK文件"><a href="#5-打包生成APK文件" class="headerlink" title="5.打包生成APK文件"></a>5.打包生成APK文件</h3><p>apkbuilder阶段。通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk。打包的工具apkbuilder位于 android-sdk/tools目录下。</p><h3 id="6-对APK文件进行签名"><a href="#6-对APK文件进行签名" class="headerlink" title="6.对APK文件进行签名"></a>6.对APK文件进行签名</h3><p>Jarsigner阶段。通过Jarsigner工具，对上面的apk进行debug或release签名。</p><h3 id="7-对签名后的APK文件进行对齐处理"><a href="#7-对签名后的APK文件进行对齐处理" class="headerlink" title="7. 对签名后的APK文件进行对齐处理"></a>7. 对签名后的APK文件进行对齐处理</h3><p>通过zipalign工具，将签名后的apk进行对齐处理。工具位于android-sdk/tools目录下。对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用。</p><p>总结一下</p><p>详细打包流程。<br><img src="/images/%E8%AF%A6%E7%BB%86%E7%9A%84%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png" alt="详细的打包流程"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindowManager的一些属性</title>
      <link href="/2020/01/05/windowsmanager-attribute/"/>
      <url>/2020/01/05/windowsmanager-attribute/</url>
      
        <content type="html"><![CDATA[<p>WindowManager(窗口管理服务)，它是显示View的最底层，Toast，Activity，Dialog的底层都有用到了这个WindowManager。WindowManager里面主要是addView，removeView，updateViewLayout这几个方法来显示View，以及通过WindowManager.LayoutParams这个API来设置相关的属性。下文讲详细介绍。</p><h1 id="WindowsManager"><a href="#WindowsManager" class="headerlink" title="WindowsManager"></a>WindowsManager</h1><h2 id="1、WindowsManager使用方法"><a href="#1、WindowsManager使用方法" class="headerlink" title="1、WindowsManager使用方法"></a>1、WindowsManager使用方法</h2><p>1</p><pre><code class="java">//获取WindowManager对象WindowManager wManager = getApplicationContext().getSystemService(Context.WINDOW_ SERVICE);//获得WindowManager.LayoutParams对象，为后续操作作准备WindowManager.LayoutParams wmParams=new WindowManager.LayoutParams();//...WindowManager.LayoutParams一顿设置wManager.addView(textView, wmParams);</code></pre><p>2</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Button floatingButton = new Button(this);        floatingButton.setText(&quot;button&quot;);        WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(                WindowManager.LayoutParams.WRAP_CONTENT,                WindowManager.LayoutParams.WRAP_CONTENT,                0, 0,                PixelFormat.TRANSPARENT        );        // flag 设置 Window 属性        layoutParams.flags= WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;        // type 设置 Window 类别（层级）        layoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY;        layoutParams.gravity = Gravity.CENTER;        WindowManager windowManager = getWindowManager();        windowManager.addView(floatingButton, layoutParams);    }}&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;</code></pre><p>3全屏设置</p><pre><code class="java">protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        //去除标题栏        requestWindowFeature(Window.FEATURE_NO_TITLE);        //去除状态栏        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,                WindowManager.LayoutParams.FLAG_FULLSCREEN);        setContentView(R.layout.activity_main);//要放到加载布局文件代码之前        initView();        initData();        initListener();}</code></pre><h2 id="2、WindowManager的关联类"><a href="#2、WindowManager的关联类" class="headerlink" title="2、WindowManager的关联类"></a>2、WindowManager的关联类</h2><h3 id="2-1、-WindowManager"><a href="#2-1、-WindowManager" class="headerlink" title="2.1、 WindowManager"></a>2.1、 WindowManager</h3><p>先来看看WindowManager里面有什么。<br><code>Android_8_0_r36_\frameworks\base\core\java\android\view\WindowManager.java</code></p><pre><code class="java">public interface WindowManager extends ViewManager {    int DOCKED_INVALID = -1;    int DOCKED_LEFT = 1;    int DOCKED_TOP = 2;    int DOCKED_RIGHT = 3;    int DOCKED_BOTTOM = 4;    final static String INPUT_CONSUMER_PIP = &quot;pip_input_consumer&quot;;    final static String INPUT_CONSUMER_NAVIGATION = &quot;nav_input_consumer&quot;;    final static String INPUT_CONSUMER_WALLPAPER = &quot;wallpaper_input_consumer&quot;;    public static class BadTokenException extends RuntimeException {        public BadTokenException() {}        public BadTokenException(String name) { super(name);}    }    public static class InvalidDisplayException extends RuntimeException {        public InvalidDisplayException() {}        public InvalidDisplayException(String name) { super(name);}    }    public Display getDefaultDisplay();    public void removeViewImmediate(View view);    public interface KeyboardShortcutsReceiver {        void onKeyboardShortcutsReceived(List&lt;KeyboardShortcutGroup&gt; result);    }    final int TAKE_SCREENSHOT_FULLSCREEN = 1;    final int TAKE_SCREENSHOT_SELECTED_REGION = 2;    public static final String PARCEL_KEY_SHORTCUTS_ARRAY = &quot;shortcuts_array&quot;;    public void requestAppKeyboardShortcuts(final KeyboardShortcutsReceiver receiver, int deviceId);    public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable {    ......    }    ...... }</code></pre><p>WindowManager是一个接口，继承ViewManager。里面有一些实例属性和方法，还有一个LayoutParams占据着很大一部分。LayoutParams是一个序列化类。而且WindowManager里面的大部分都是隐藏的属性和方法，只给系统调用。</p><h3 id="2-2、ViewManager"><a href="#2-2、ViewManager" class="headerlink" title="2.2、ViewManager"></a>2.2、ViewManager</h3><p>WindowManager继承ViewManager。ViewManager里面实际上只有三个方法：<code>addView</code>、<code>updateViewLayout</code>、<code>removeView</code>，分别对应着添加view、更新viewlayout、移走view。</p><p>\frameworks\base\core\java\android\view\ViewManager.java</p><pre><code class="java">package android.view;public interface ViewManager{    public void addView(View view, ViewGroup.LayoutParams params);    public void updateViewLayout(View view, ViewGroup.LayoutParams params);    public void removeView(View view);}</code></pre><h3 id="2-3、WindowManagerImpl"><a href="#2-3、WindowManagerImpl" class="headerlink" title="2.3、WindowManagerImpl"></a>2.3、WindowManagerImpl</h3><p>那么WindowManager的实现类是哪个？是WindowManagerImpl。<br><code>Android_8_0_r36_\frameworks\base\core\java\android\view\WindowManagerImpl.java</code></p><pre><code class="java">public final class WindowManagerImpl implements WindowManager {    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();    private final Context mContext;    private final Window mParentWindow;    private IBinder mDefaultToken;    public WindowManagerImpl(Context context) {        this(context, null);    }    private WindowManagerImpl(Context context, Window parentWindow) {        mContext = context;        mParentWindow = parentWindow;    }    public WindowManagerImpl createLocalWindowManager(Window parentWindow) {        return new WindowManagerImpl(mContext, parentWindow);    }    public WindowManagerImpl createPresentationWindowManager(Context displayContext) {        return new WindowManagerImpl(displayContext, mParentWindow);    }    public void setDefaultToken(IBinder token) {        mDefaultToken = token;    }    @Override    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {        applyDefaultToken(params);        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);    }    @Override    public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {        applyDefaultToken(params);        mGlobal.updateViewLayout(view, params);    }    private void applyDefaultToken(@NonNull ViewGroup.LayoutParams params) {        // Only use the default token if we don&#39;t have a parent window.        if (mDefaultToken != null &amp;&amp; mParentWindow == null) {            if (!(params instanceof WindowManager.LayoutParams)) {                throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);            }            // Only use the default token if we don&#39;t already have a token.            final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;            if (wparams.token == null) {                wparams.token = mDefaultToken;            }        }    }    @Override    public void removeView(View view) {        mGlobal.removeView(view, false);    }    @Override    public void removeViewImmediate(View view) {        mGlobal.removeView(view, true);    }    @Override    public void requestAppKeyboardShortcuts(            final KeyboardShortcutsReceiver receiver, int deviceId) {        IResultReceiver resultReceiver = new IResultReceiver.Stub() {            @Override            public void send(int resultCode, Bundle resultData) throws RemoteException {                List&lt;KeyboardShortcutGroup&gt; result =                        resultData.getParcelableArrayList(PARCEL_KEY_SHORTCUTS_ARRAY);                receiver.onKeyboardShortcutsReceived(result);            }        };        try {            WindowManagerGlobal.getWindowManagerService()                .requestAppKeyboardShortcuts(resultReceiver, deviceId);        } catch (RemoteException e) {        }    }    @Override    public Display getDefaultDisplay() {        return mContext.getDisplay();    }    @Override    public Region getCurrentImeTouchRegion() {        try {            return WindowManagerGlobal.getWindowManagerService().getCurrentImeTouchRegion();        } catch (RemoteException e) {        }        return null;    }}</code></pre><p>可以看到实现类里面主要的参数是下面这几个。</p><pre><code class="java">    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();    private final Context mContext;    private final Window mParentWindow;    private IBinder mDefaultToken;</code></pre><p>里面最主要的是WindowManagerGlobal了，view的增删改都是由它完成的。<br>WindowManagerGlobal里面主要管理是一下一些参数。view的相关控制用ArrayList装载着。<br><code>Android_8_0_r36_\frameworks\base\core\java\android\view\WindowManagerGlobal.java</code></p><pre><code class="java">    private static WindowManagerGlobal sDefaultWindowManager;    private static IWindowManager sWindowManagerService;    private static IWindowSession sWindowSession;    private final Object mLock = new Object();    private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();    private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();    private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams =            new ArrayList&lt;WindowManager.LayoutParams&gt;();    private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();    private Runnable mSystemPropertyUpdater;</code></pre><p>addView<br><code>Android_8_0_r36_\frameworks\base\core\java\android\view\WindowManagerGlobal.java</code></p><pre><code class="java">    public void addView(View view, ViewGroup.LayoutParams params,            Display display, Window parentWindow) {        if (view == null) {            throw new IllegalArgumentException(&quot;view must not be null&quot;);        }        if (display == null) {            throw new IllegalArgumentException(&quot;display must not be null&quot;);        }        if (!(params instanceof WindowManager.LayoutParams)) {            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);        }        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;        if (parentWindow != null) {            parentWindow.adjustLayoutParamsForSubWindow(wparams);        } else {            // If there&#39;s no parent, then hardware acceleration for this view is            // set from the application&#39;s hardware acceleration setting.            final Context context = view.getContext();            if (context != null                    &amp;&amp; (context.getApplicationInfo().flags                            &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;            }        }        ViewRootImpl root;        View panelParentView = null;        synchronized (mLock) {            // Start watching for system property changes.            if (mSystemPropertyUpdater == null) {                mSystemPropertyUpdater = new Runnable() {                    @Override public void run() {                        synchronized (mLock) {                            for (int i = mRoots.size() - 1; i &gt;= 0; --i) {                                mRoots.get(i).loadSystemProperties();                            }                        }                    }                };                SystemProperties.addChangeCallback(mSystemPropertyUpdater);            }            int index = findViewLocked(view, false);            if (index &gt;= 0) {                if (mDyingViews.contains(view)) {                    // Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue.                    mRoots.get(index).doDie();                } else {                    throw new IllegalStateException(&quot;View &quot; + view                            + &quot; has already been added to the window manager.&quot;);                }                // The previous removeView() had not completed executing. Now it has.            }            // If this is a panel window, then find the window it is being            // attached to for future reference.            if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;                    wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) {                final int count = mViews.size();                for (int i = 0; i &lt; count; i++) {                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {                        panelParentView = mViews.get(i);                    }                }            }            root = new ViewRootImpl(view.getContext(), display);            view.setLayoutParams(wparams);            mViews.add(view);            mRoots.add(root);            mParams.add(wparams);            // do this last because it fires off messages to start doing things            try {                root.setView(view, wparams, panelParentView);            } catch (RuntimeException e) {                // BadTokenException or InvalidDisplayException, clean up.                if (index &gt;= 0) {                    removeViewLocked(index, true);                }                throw e;            }        }    }</code></pre><p>updateViewLayout<br><code>Android_8_0_r36_\frameworks\base\core\java\android\view\WindowManagerGlobal.java</code></p><pre><code class="java">    public void updateViewLayout(View view, ViewGroup.LayoutParams params) {        if (view == null) {            throw new IllegalArgumentException(&quot;view must not be null&quot;);        }        if (!(params instanceof WindowManager.LayoutParams)) {            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);        }        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;        view.setLayoutParams(wparams);        synchronized (mLock) {            int index = findViewLocked(view, true);            ViewRootImpl root = mRoots.get(index);            mParams.remove(index);            mParams.add(index, wparams);            root.setLayoutParams(wparams, false);        }    }</code></pre><p>removeView<br><code>Android_8_0_r36_\frameworks\base\core\java\android\view\WindowManagerGlobal.java</code></p><pre><code class="java">    public void removeView(View view, boolean immediate) {        if (view == null) {            throw new IllegalArgumentException(&quot;view must not be null&quot;);        }        synchronized (mLock) {            int index = findViewLocked(view, true);            View curView = mRoots.get(index).getView();            removeViewLocked(index, immediate);            if (curView == view) {                return;            }            throw new IllegalStateException(&quot;Calling with view &quot; + view                    + &quot; but the ViewAncestor is attached to &quot; + curView);        }    }</code></pre><h2 id="3、WindowManager-的一些属性"><a href="#3、WindowManager-的一些属性" class="headerlink" title="3、WindowManager 的一些属性"></a>3、WindowManager 的一些属性</h2><p>WindowManager.LayoutParams属性里面主要有Type属性和Flags属性。</p><p>Type表示Window的类型，Window有三种类型，分别是应用窗口、子窗口和系统窗口。<br><code>\frameworks\base\core\java\android\view\ViewManager.java</code></p><pre><code class="java">        /**         * Start of window types that represent normal application windows.         */        public static final int FIRST_APPLICATION_WINDOW = 1;        public static final int TYPE_BASE_APPLICATION   = 1;//一个应用程序窗口,作为“基础”窗口 　        public static final int TYPE_APPLICATION        = 2;//正常的应用程序窗口        public static final int TYPE_APPLICATION_STARTING = 3;//特殊应用程序窗口显示        public static final int TYPE_DRAWN_APPLICATION = 4;//显示前绘画        public static final int LAST_APPLICATION_WINDOW = 99;//End of types of application windows.        //子窗口        public static final int FIRST_SUB_WINDOW = 1000;        public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;//应用面板        public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;//窗口显示媒体(如视频)        public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;//应用程序窗口的顶部        public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;//类似TYPE_APPLICATION_PANEL，布局为顶级窗口        public static final int TYPE_APPLICATION_MEDIA_OVERLAY  = FIRST_SUB_WINDOW + 4;//显示媒体层叠窗口        public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;//上面一个sub-panel之上的应用程序的窗口                public static final int LAST_SUB_WINDOW = 1999;//子系统结尾        /**         * Start of system-specific window types.           */        public static final int FIRST_SYSTEM_WINDOW     = 2000;//These are not normally created by applications.        public static final int TYPE_STATUS_BAR         = FIRST_SYSTEM_WINDOW;//状态栏。只能有一个状态栏         public static final int TYPE_SEARCH_BAR         = FIRST_SYSTEM_WINDOW+1;//搜索栏。只能有一个搜索栏        public static final int TYPE_PHONE              = FIRST_SYSTEM_WINDOW+2;//电话        public static final int TYPE_SYSTEM_ALERT       = FIRST_SYSTEM_WINDOW+3;//系统窗口,如低功率警觉        public static final int TYPE_KEYGUARD           = FIRST_SYSTEM_WINDOW+4;//键盘守卫窗口        public static final int TYPE_TOAST              = FIRST_SYSTEM_WINDOW+5;//临时通知。        public static final int TYPE_SYSTEM_OVERLAY     = FIRST_SYSTEM_WINDOW+6;//系统覆盖窗口,它需要显示出来        public static final int TYPE_PRIORITY_PHONE     = FIRST_SYSTEM_WINDOW+7;//优先电话界面,需要即使显示        public static final int TYPE_SYSTEM_DIALOG      = FIRST_SYSTEM_WINDOW+8;//从状态栏面板幻灯片         public static final int TYPE_KEYGUARD_DIALOG    = FIRST_SYSTEM_WINDOW+9;//键盘守卫显示对话        public static final int TYPE_SYSTEM_ERROR       = FIRST_SYSTEM_WINDOW+10;//内部系统错误窗口,出现在上面         public static final int TYPE_INPUT_METHOD       = FIRST_SYSTEM_WINDOW+11;//内部输入法窗口,上面出现        public static final int TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+12;//内部输入方法对话框窗口,上面出现        public static final int TYPE_WALLPAPER          = FIRST_SYSTEM_WINDOW+13;//壁纸窗口,放在任何想要的窗口         public static final int TYPE_STATUS_BAR_PANEL   = FIRST_SYSTEM_WINDOW+14;//面板幻灯片从状态栏         public static final int TYPE_SECURE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+15;//安全系统覆盖窗口        public static final int TYPE_DRAG               = FIRST_SYSTEM_WINDOW+16;//拖动图层，放在最上面        public static final int TYPE_STATUS_BAR_SUB_PANEL = FIRST_SYSTEM_WINDOW+17;//从状态栏下面板,幻灯片        public static final int TYPE_POINTER = FIRST_SYSTEM_WINDOW+18;//(鼠标)指针         public static final int TYPE_NAVIGATION_BAR = FIRST_SYSTEM_WINDOW+19;//导航栏(有别于状态栏时)         public static final int TYPE_VOLUME_OVERLAY = FIRST_SYSTEM_WINDOW+20;//音量级别覆盖/对话框显示        public static final int TYPE_BOOT_PROGRESS = FIRST_SYSTEM_WINDOW+21;//引导进度对话框，在所有窗口之上        public static final int TYPE_INPUT_CONSUMER = FIRST_SYSTEM_WINDOW+22;//当系统UI隐藏时候输入事件        public static final int TYPE_DREAM = FIRST_SYSTEM_WINDOW+23;//屏保窗口        public static final int TYPE_NAVIGATION_BAR_PANEL = FIRST_SYSTEM_WINDOW+24;//导航栏面板        public static final int TYPE_DISPLAY_OVERLAY = FIRST_SYSTEM_WINDOW+26;//显示窗口覆盖        public static final int TYPE_MAGNIFICATION_OVERLAY = FIRST_SYSTEM_WINDOW+27;//放大窗口覆盖        public static final int TYPE_PRIVATE_PRESENTATION = FIRST_SYSTEM_WINDOW+30;//私有虚拟显示在顶部的描述        public static final int TYPE_VOICE_INTERACTION = FIRST_SYSTEM_WINDOW+31;//声音交互        public static final int TYPE_ACCESSIBILITY_OVERLAY = FIRST_SYSTEM_WINDOW+32;        public static final int TYPE_VOICE_INTERACTION_STARTING = FIRST_SYSTEM_WINDOW+33;        public static final int TYPE_DOCK_DIVIDER = FIRST_SYSTEM_WINDOW+34;        public static final int TYPE_QS_DIALOG = FIRST_SYSTEM_WINDOW+35;        public static final int TYPE_SCREENSHOT = FIRST_SYSTEM_WINDOW + 36;        public static final int TYPE_PRESENTATION = FIRST_SYSTEM_WINDOW + 37;        public static final int TYPE_APPLICATION_OVERLAY = FIRST_SYSTEM_WINDOW + 38;        public static final int LAST_SYSTEM_WINDOW      = 2999;//系统窗口结尾</code></pre><p>应用窗口从1开始，到99。子窗口范围为1000 ~ 1999 ，系统窗口范围为2000~2999。子窗口表示依赖于应用窗口的窗口，比如PopupWindow就是依赖于应用的子窗口。Android系统有个X,Y,Z轴的坐标体系。X表示横轴，Y表示竖轴，Z表示垂直于平面的轴。这些窗口数值对应的事Z轴。数字越大表示越靠近用户。从上面的数值可以看出，系统窗口是最靠近用户的，其次是子窗口，最后是应用窗口。<br>Flags参数表示Window的属性，控制着Window的显示特性。</p><pre><code class="java">       FLAG_ALLOW_LOCK_WHILE_SCREEN_ON       FLAG_DIM_BEHIND       FLAG_NOT_FOCUSABLE//不获取焦点，不接收各种输入事件,由后面的窗口得到焦点       FLAG_NOT_TOUCHABLE       FLAG_NOT_TOUCH_MODAL//不获取触摸事件，由后面的窗口得到触摸事件       FLAG_TOUCHABLE_WHEN_WAKING       FLAG_KEEP_SCREEN_ON       FLAG_LAYOUT_IN_SCREEN       FLAG_LAYOUT_NO_LIMITS       FLAG_FULLSCREEN       FLAG_FORCE_NOT_FULLSCREEN       FLAG_SECURE       FLAG_SCALED       FLAG_IGNORE_CHEEK_PRESSES       FLAG_LAYOUT_INSET_DECOR       FLAG_ALT_FOCUSABLE_IM       FLAG_WATCH_OUTSIDE_TOUCH       FLAG_SHOW_WHEN_LOCKED    //让Window显示在锁屏的界面上       FLAG_SHOW_WALLPAPER       FLAG_TURN_SCREEN_ON       FLAG_DISMISS_KEYGUARD       FLAG_SPLIT_TOUCH       FLAG_HARDWARE_ACCELERATED       FLAG_LOCAL_FOCUS_MODE       FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</code></pre><p>Flags标识按位来增加，比如下面这这些。当几个功能叠加的时候可以用或运算。<br><code>flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE</code></p><pre><code class="java">public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON     = 0x00000001;public static final int FLAG_DIM_BEHIND                     = 0x00000002;public static final int FLAG_BLUR_BEHIND                    = 0x00000004;public static final int FLAG_NOT_FOCUSABLE                  = 0x00000008;public static final int FLAG_NOT_TOUCHABLE                  = 0x00000010;public static final int FLAG_NOT_TOUCH_MODAL                = 0x00000020;public static final int FLAG_TOUCHABLE_WHEN_WAKING          = 0x00000040;public static final int FLAG_KEEP_SCREEN_ON                 = 0x00000080;public static final int FLAG_LAYOUT_IN_SCREEN               = 0x00000100;......public static final int FLAG_SHOW_WHEN_LOCKED               = 0x00080000;......</code></pre><p>不止这两个属性设置，还有softInputMode，gravity，horizontalMargin，verticalMargin，screenBrightness，buttonBrightness，rotationAnimation等等的参数设置。WindowManager.LayoutParams里面有<code>addFlags</code>、<code>clearFlags</code>、<code>setColorMode</code>等来控制这些属性的设置。<br>softInputMode是软键盘设置，可以看下它的几个参数。</p><pre><code class="java">            SOFT_INPUT_STATE_UNSPECIFIED,            SOFT_INPUT_STATE_UNCHANGED,            SOFT_INPUT_STATE_HIDDEN,            SOFT_INPUT_STATE_ALWAYS_HIDDEN,            SOFT_INPUT_STATE_VISIBLE,            SOFT_INPUT_STATE_ALWAYS_VISIBLE,            SOFT_INPUT_ADJUST_UNSPECIFIED,            SOFT_INPUT_ADJUST_RESIZE,            SOFT_INPUT_ADJUST_PAN,            SOFT_INPUT_ADJUST_NOTHING,            SOFT_INPUT_IS_FORWARD_NAVIGATION,</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windowsmanager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DownlaodManager下载安装APP</title>
      <link href="/2020/01/05/downlaodmanager-download-app/"/>
      <url>/2020/01/05/downlaodmanager-download-app/</url>
      
        <content type="html"><![CDATA[<p>这里是利用android自身的DownlaodManager来下载APP。下面是代码。</p><pre><code class="java">import android.app.Activity;import android.app.DownloadManager;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.database.ContentObserver;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Environment;import android.os.Handler;import android.support.v4.content.FileProvider;import android.text.TextUtils;import android.util.Log;import java.io.File;import java.lang.ref.WeakReference;/** * Created by okloong on 2019/8/9 0009 上午 00:15. * Describe: */public class AppDownloadManager {    public static final String TAG = &quot;AppDownloadManager&quot;;    private WeakReference&lt;Activity&gt; weakReference;    private DownloadManager mDownloadManager;    private DownloadChangeObserver mDownLoadChangeObserver;    private DownloadReceiver mDownloadReceiver;    private long mReqId;    private OnUpdateListener mUpdateListener;    public AppDownloadManager(Activity activity) {        weakReference = new WeakReference&lt;Activity&gt;(activity);        mDownloadManager = (DownloadManager) weakReference.get().getSystemService(Context.DOWNLOAD_SERVICE);        mDownLoadChangeObserver = new DownloadChangeObserver(new Handler());        mDownloadReceiver = new DownloadReceiver();    }    public void setUpdateListener(OnUpdateListener mUpdateListener) {        this.mUpdateListener = mUpdateListener;    }    public void downloadApk(String apkUrl, String title, String desc) {        // fix bug : 装不了新版本，在下载之前应该删除已有文件        File apkFile = new File(weakReference.get().getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), &quot;app_name.apk&quot;);        if (apkFile != null &amp;&amp; apkFile.exists()) {            apkFile.delete();        }        DownloadManager.Request request = new DownloadManager.Request(Uri.parse(apkUrl));        //设置title        request.setTitle(title);        // 设置描述        request.setDescription(desc);        // 完成后显示通知栏        request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);        request.setDestinationInExternalFilesDir(weakReference.get(), Environment.DIRECTORY_DOWNLOADS, &quot;app_name.apk&quot;);        //在手机SD卡上创建一个download文件夹        // Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).mkdir() ;        //指定下载到SD卡的/download/my/目录下        // request.setDestinationInExternalPublicDir(&quot;/codoon/&quot;,&quot;codoon_health.apk&quot;);        request.setMimeType(&quot;application/vnd.android.package-archive&quot;);        //        mReqId = mDownloadManager.enqueue(request);    }    /**     * 取消下载     */    public void cancel() {        mDownloadManager.remove(mReqId);    }    /**     * 对应 {@link Activity }     */    public void resume() {        //设置监听Uri.parse(&quot;content://downloads/my_downloads&quot;)        weakReference.get().getContentResolver().registerContentObserver(Uri.parse(&quot;content://downloads/my_downloads&quot;), true,                mDownLoadChangeObserver);        // 注册广播，监听APK是否下载完成        weakReference.get().registerReceiver(mDownloadReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));    }    /**     * 对应{@ link Activity# onPause()} () }     */    public void onPause() {        weakReference.get().getContentResolver().unregisterContentObserver(mDownLoadChangeObserver);        weakReference.get().unregisterReceiver(mDownloadReceiver);    }    private void updateView() {        int[] bytesAndStatus = new int[]{0, 0, 0};        DownloadManager.Query query = new DownloadManager.Query().setFilterById(mReqId);        Cursor c = null;        try {            c = mDownloadManager.query(query);            if (c != null &amp;&amp; c.moveToFirst()) {                //已经下载的字节数                bytesAndStatus[0] = c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));                //总需下载的字节数                bytesAndStatus[1] = c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));                //状态所在的列索引                bytesAndStatus[2] = c.getInt(c.getColumnIndex(DownloadManager.COLUMN_STATUS));            }        } finally {            if (c != null) {                c.close();            }        }        if (mUpdateListener != null) {            mUpdateListener.update(bytesAndStatus[0], bytesAndStatus[1]);        }        Log.i(TAG, &quot;下载进度：&quot; + bytesAndStatus[0] + &quot;/&quot; + bytesAndStatus[1] + &quot;&quot;);    }    class DownloadChangeObserver extends ContentObserver {        /**         * Creates a content observer.         *         * @param handler The handler to run {@link #onChange} on, or null if none.         */        public DownloadChangeObserver(Handler handler) {            super(handler);        }        @Override        public void onChange(boolean selfChange) {            super.onChange(selfChange);            updateView();        }    }    class DownloadReceiver extends BroadcastReceiver {        @Override        public void onReceive(final Context context, final Intent intent) {            boolean haveInstallPermission;            // 兼容Android 8.0            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {                //先获取是否有安装未知来源应用的权限                haveInstallPermission = context.getPackageManager().canRequestPackageInstalls();                if (!haveInstallPermission) {//没有权限                    // 弹窗，并去设置页面授权                    final AndroidOInstallPermissionListener listener = new AndroidOInstallPermissionListener() {                        @Override                        public void permissionSuccess() {                            Log.i(TAG, &quot;下载成功！准备安装&quot;);                            installApk(context, intent);                        }                        @Override                        public void permissionFail() {//                            ToastUtils.shortToast(context, &quot;授权失败，无法安装应用&quot;);                        }                    };//                    AndroidOPermissionActivity.sListener = listener;//                    Intent intent1 = new Intent(context, AndroidOPermissionActivity.class);//                    context.startActivity(intent1);                } else {                    installApk(context, intent);                }            } else {                installApk(context, intent);            }        }    }    /**     * @param context     * @param intent     */    private void installApk(Context context, Intent intent) {        long completeDownLoadId = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);        Log.e(TAG, &quot;收到广播&quot;);        Uri uri;        Intent intentInstall = new Intent();        intentInstall.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        intentInstall.setAction(Intent.ACTION_VIEW);        if (completeDownLoadId == mReqId) {            if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { // 6.0以下                uri = mDownloadManager.getUriForDownloadedFile(completeDownLoadId);            } else if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) { // 6.0 - 7.0                File apkFile = queryDownloadedApk(context, completeDownLoadId);                uri = Uri.fromFile(apkFile);            } else { // Android 7.0 以上                uri = FileProvider.getUriForFile(context,                        &quot;com.okloong.appfile.fileProvider&quot;,                        new File(context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), &quot;app_name.apk&quot;));                intentInstall.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);            }            // 安装应用            Log.e(TAG, &quot;下载完成了&quot;);            intentInstall.setDataAndType(uri, &quot;application/vnd.android.package-archive&quot;);            context.startActivity(intentInstall);        }    }    //通过downLoadId查询下载的apk，解决6.0以后安装的问题    public static File queryDownloadedApk(Context context, long downloadId) {        File targetApkFile = null;        DownloadManager downloader = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);        if (downloadId != -1) {            DownloadManager.Query query = new DownloadManager.Query();            query.setFilterById(downloadId);            query.setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL);            Cursor cur = downloader.query(query);            if (cur != null) {                if (cur.moveToFirst()) {                    String uriString = cur.getString(cur.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI));                    if (!TextUtils.isEmpty(uriString)) {                        targetApkFile = new File(Uri.parse(uriString).getPath());                    }                }                cur.close();            }        }        return targetApkFile;    }    public interface OnUpdateListener {        void update(int currentByte, int totalByte);    }    public interface AndroidOInstallPermissionListener {        void permissionSuccess();        void permissionFail();    }}</code></pre><p>在AndroidMainfest的``标签里面添加prvoider。</p><pre><code class="xml">        &lt;provider            android:name=&quot;android.support.v4.content.FileProvider&quot;            android:authorities=&quot;com.okloong.appfile.fileProvider&quot;            android:exported=&quot;false&quot;            android:grantUriPermissions=&quot;true&quot;&gt;            &lt;meta-data                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;                android:resource=&quot;@xml/filepath&quot; /&gt;        &lt;/provider&gt;</code></pre><p>res目录下新建xml目录，然后新建filepath.xml文件。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;        &lt;paths &gt;        &lt;external-path            name=&quot;download&quot;            path=&quot;&quot; /&gt;        &lt;/paths&gt;&lt;/resources&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> downlaodmanager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NDK调用非JNI标准的so文件</title>
      <link href="/2020/01/05/ndk-so-file/"/>
      <url>/2020/01/05/ndk-so-file/</url>
      
        <content type="html"><![CDATA[<p>调用so文件有两种方式，一种是标准的jni文件，另外一种不是jni标准。jni标准可以直接用jni标准来调用，非jni标准的需要外面包裹一层jni标准才能调用。下面就演示怎么用。</p><p>NKD可以用ndk-build来编译，也可以用cmake来编译。这里用的是cmake。<br>CMakeList.txt内容。</p><pre><code class="txt"># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# 这里设置外部代码根目录set(distribution_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../../../distribution)#调用第三方so文件add_library(slzr-lib SHARED IMPORTED)set_target_properties(slzr-lib PROPERTIES IMPORTED_LOCATION        ${distribution_DIR}/slzr/lib/${ANDROID_ABI}/libslzr.so)#set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=gnu++11&quot;)#主so文件配置add_library(native-lib        SHARED        #这里设置需要引入的c文件#        ${distribution_DIR}/slzr/src/libposapplication.cpp        native-lib.cpp)#这里设置生成so文件的输出目录，可以不设置set_target_properties(native-lib        PROPERTIES        LIBRARY_OUTPUT_DIRECTORY        &quot;${distribution_DIR}/native-lib/lib/${ANDROID_ABI}&quot;)#这里设置外部源码位置target_include_directories(native-lib PRIVATE#        ${distribution_DIR}/slzr/src        ${distribution_DIR}/slzr/include)find_library(log-lib        log)target_link_libraries(native-lib        slzr-lib   #第三方so文件        ${log-lib})</code></pre><p>CMakeList里面设置了第三方的so库地址。<br>值得注意的是set_target_properties设置需要放到对应的add_library的下面。target_link_libraries需要加入第三方so文件的名称。<br>我这里直接生成一个测试的非标准的jni文件给项目来调用。</p><p>这里是封装的c++调用。</p><pre><code class="cpp">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &quot;stdint.h&quot;#include &lt;libposapplication_global.h&gt;#include &lt;libposapplication.h&gt;#include&lt;android/log.h&gt;#define LOG_TAG &quot;System.out.c&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)/** * 封装c/c++与java的接口 */int soso(char *data) {    printf(&quot;*********test*********&quot;);    std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;    LOGI(&quot;这是来自tsoso&quot;);    return 1;}extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_ndktest2_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) {    std::string hello = &quot;Hello from C++&quot;;    LOGD(&quot;调用了testapp&quot;);    testapp();    LOGI(&quot;这是来自so里面的info信息&quot;);    IC_test cal;    cal.call_test = soso;    int i = call_back(&amp;cal);    LOGI(&quot;这是来自so里面的info123&quot;);    return env-&gt;NewStringUTF(hello.c_str());}</code></pre><p>代码比简单，<code>testapp();</code>是so文件里面的函数。<code>call_back</code>是so文件里面回调函数。这里设置<code>int soso(char *data)</code>为回调函数加进去。<br>下面看下非JNI标准的c代码。</p><pre><code class="cpp">#include &quot;libposapplication.h&quot;#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&quot;stdint.h&quot;LibPosApplication::LibPosApplication(){ printf(&quot;测试lib&quot;);}LIBPOSAPPLICATIONSHARED_EXPORT void testapp(){     printf(&quot;*********test*********&quot;);     std::cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;std::endl;    LOGI(&quot;这是来自testapp&quot;);}extern &quot;C&quot;{LIBPOSAPPLICATIONSHARED_EXPORT int call_back(IC_test *body){    int ret;    printf(&quot;%s\n&quot;,__FUNCTION__);       std::cout&lt;&lt;&quot;Hello call_back!&quot;&lt;&lt;std::endl;    ret=(body-&gt;call_test)(&quot;你好啊&quot;);    return 1;}}//回调函数实现</code></pre><p>附件：<br><a href="https://github.com/loongX/NDKSamples/tree/master/NDK-Libs" target="_blank" rel="noopener">demo源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NDK动态注册</title>
      <link href="/2020/01/05/ndk-dynamicregistration/"/>
      <url>/2020/01/05/ndk-dynamicregistration/</url>
      
        <content type="html"><![CDATA[<p>c/c++和java交互，需要找到双方各自对应的函数或方法来调用。这种产生联系的方式有两种方式，一个是静态注册，另一种事动态注册。动态注册是比静态注册的好处是不需要JNI那一套很长的命名。</p><p>其他的规则和静态注册无异，只是注册的地方不同而已。</p><p>下面是动态注册的方式。</p><pre><code class="c">/** * 动态注册 */extern &quot;C&quot; {jstring stringFromJNI2(JNIEnv *env, jobject instance) {    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());}jint add(JNIEnv *env, jclass clazz, jint a, jint b) {    LOGE(&quot;ADD!!&quot;);    return a + b;}#define JNIREG_CLASS &quot;com/slzr/ndk/NDKManager&quot;//指定要注册的类/*** 方法对应表*/static JNINativeMethod gMethods[] = {//        {&quot;stringFromJNI2&quot;, &quot;()Ljava/lang/String;&quot;, (void *) stringFromJNI2},        {&quot;add&quot;,            &quot;(II)I&quot;,                (void *) add}};/** 为某一个类注册本地方法*/static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods,                                 int numMethods) {    jclass clazz;    clazz = env-&gt;FindClass(className);    if (clazz == NULL) {        return JNI_FALSE;    }    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {        return JNI_FALSE;    }    return JNI_TRUE;}/** 为所有类注册本地方法*/static int registerNatives(JNIEnv *env) {    return registerNativeMethods(env, JNIREG_CLASS, gMethods,                                 sizeof(gMethods) / sizeof(gMethods[0]));}/** System.loadLibrary(&quot;lib&quot;)时调用* 如果成功返回JNI版本, 失败返回-1*/JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {    JNIEnv *env = NULL;    jint result = -1;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) {        return -1;    }    assert(env != NULL);    if (!registerNatives(env)) {//注册        return -1;    }    //成功    result = JNI_VERSION_1_6;    return result;}}</code></pre><p>这里说明一下，<code>JNI_OnLoad</code>是<code>System.loadLibrary</code>加载完动态库执行的函数，写在jni.h里面。<br><code>registerNatives</code>写本地的方法。<code>gMethods</code>写方法列表，第一参数是java里面的方法名称，第二参数是方法输入参数，第三个参数是c/c++里面对应的函数。它的结构类型如下：</p><pre><code class="c">typedef struct {    const char* name;    const char* signature;    void*       fnPtr;} JNINativeMethod;</code></pre><p>第二个参数可以参照java的反射。</p><pre><code>字符 Java类型 C类型V      void            voidZ       jboolean     booleanI        jint              intJ       jlong            longD      jdouble       doubleF      jfloat            floatB      jbyte            byteC      jchar           charS      jshort          short数组则以&quot;[&quot;开始，用两个字符表示。[I       jintArray      int[][F     jfloatArray    float[][B     jbyteArray    byte[][C    jcharArray    char[][S    jshortArray   short[][D    jdoubleArray double[][J     jlongArray     long[][Z    jbooleanArray boolean[]</code></pre><p>gMethods里面的第二参数<code>()</code>表示输入参数，有多少就写多少进去。比如说两个int参数，就写<code>(II)</code>。括号后面跟着的是返回值<code>V</code>表示没有返回值void。<code>Ljava/lang/String;</code>对应是String类型。<code>Ljava/lang/Object;</code>对应是Object类型。</p><p>在java层面仍然需要native 编写。</p><pre><code class="java">    public native int add(int a, int b);</code></pre><p>附件：<br><a href="https://github.com/loongX/NDKSamples/tree/master/NDK-DynamicRegistration" target="_blank" rel="noopener">demo源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NDK基础知识</title>
      <link href="/2020/01/05/ndk-base/"/>
      <url>/2020/01/05/ndk-base/</url>
      
        <content type="html"><![CDATA[<p>下面介绍NDK相关基础性的知识。</p><h1 id="打印log"><a href="#打印log" class="headerlink" title="打印log"></a>打印log</h1><p>一般调试ndk都需要log。那怎么打印log呢？<br>下面是打印log的方法。</p><pre><code class="c">#include &lt;jni.h&gt;#include&lt;android/log.h&gt;#define LOG_TAG &quot;System.out.c&quot;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)</code></pre><p>这里用宏定义定义了android系统下几个log打印。<code>__VA_ARGS__</code>代表宏参数<code>...</code>，括号内 … 的内容原样抄写在<code>__VA_ARGS__</code>的位置。<br>使用方法如下，在适合的地方调用该方法。</p><pre><code class="c">LOGD(&quot;这里打印log&quot;);LOGI(&quot;这是来自info信息&quot;);</code></pre><h1 id="java调用c的函数"><a href="#java调用c的函数" class="headerlink" title="java调用c的函数"></a>java调用c的函数</h1><p>这里介绍的是静态注册的方法。</p><pre><code class="c">extern &quot;C&quot; {// Data callback stuffJavaVM* theJvm;jobject dataCallbackObj;jmethodID midDataCallback;/** * Initializes JNI interface stuff, specifically the info needed to call back into the Java * layer when MIDI data is received. */JNICALL void Java_com_slzr_ndk_NDKManager_initNative(JNIEnv * env, jobject instance) {    env-&gt;GetJavaVM(&amp;theJvm);    // Setup the receive data callback (into Java)    jclass clsNDKManager = env-&gt;FindClass(&quot;com/slzr/ndk/NDKManager&quot;);    dataCallbackObj = env-&gt;NewGlobalRef(instance);    midDataCallback = env-&gt;GetMethodID(clsNDKManager, &quot;onNativeMessageReceive&quot;, &quot;([B)V&quot;);//[B}} // extern &quot;C&quot;</code></pre><p>当JVM调用这些函数，就传递一个JNIEnv指针，一个jobject的指针，你说看到是输入参数里面有<code>(JNIEnv * env, jobject instance)</code>就是这个东西了。<br>Java_com_slzr_ndk_NDKManager_initNative包含有了包名，类名和方法名，中间用下划线分开。由于该方法是没有返回值，所以直接用了<code>JNICALL</code>，如果有返回值比如说是String返回，用<code>JNIEXPORT jstring JNICALL</code>这样的形式。JNIEXPORT和JNICALL中间夹着返回值。</p><p>对应到java里面的方法是。</p><pre><code class="java">    public native void initNative();</code></pre><p>native 是java里面的关键字，表示地调用c语言里面的函数。</p><h1 id="c调用java的方法"><a href="#c调用java的方法" class="headerlink" title="c调用java的方法"></a>c调用java的方法</h1><p>在NDK里面c调用java的方法类似于反射。<br>需要先获取到对应的方法名称，虚拟机等。</p><p>这个回去相关的信息的c代码。</p><pre><code class="c">#include &lt;jni.h&gt;extern &quot;C&quot; {// Data callback stuffJavaVM* theJvm;jobject dataCallbackObj;jmethodID midDataCallback;/** * Initializes JNI interface stuff, specifically the info needed to call back into the Java * layer when MIDI data is received. */JNICALL void Java_com_slzr_ndk_NDKManager_initNative(JNIEnv * env, jobject instance) {    env-&gt;GetJavaVM(&amp;theJvm);    // Setup the receive data callback (into Java)    jclass clsNDKManager = env-&gt;FindClass(&quot;com/slzr/ndk/NDKManager&quot;);    dataCallbackObj = env-&gt;NewGlobalRef(instance);    midDataCallback = env-&gt;GetMethodID(clsNDKManager, &quot;onNativeMessageReceive&quot;, &quot;([B)V&quot;);//[B}} // extern &quot;C&quot;</code></pre><p>initNative是初始化函数，对应java里面的<code>public native void initNative();</code>调用。env是java虚拟机对象，instance是Object。在这里，先获取到对应的class对象、Object对象和对应的方法。</p><p>下面的c调用java里面的方法。</p><pre><code class="c">// The Data Callbackextern JavaVM *theJvm;              // Need this for allocating data buffer for...extern jobject dataCallbackObj;     // This is the (Java) object that implements...extern jmethodID midDataCallback;   // ...this callback routineint soso(char *data) {    ......    JNIEnv *env;    theJvm-&gt;AttachCurrentThread(&amp;env, NULL);    if (env == NULL) {        LOGI(&quot;Error retrieving JNI Env&quot;);    }    // Allocate the Java array and fill with received data    jbyteArray ret = env-&gt;NewByteArray(strlen(data));    env-&gt;SetByteArrayRegion(ret, 0, strlen(data), (jbyte *) data);    // send it to the (Java) callback    env-&gt;CallVoidMethod(dataCallbackObj, midDataCallback, ret);    return 1;}</code></pre><p>这里是上面保存下来的相关参数再调用一次。jbyteArray 是转换成java里面的数组。可以在java里面写相对应的实现。<br>这是调用java里面的onNativeMessageReceive方法。</p><pre><code class="java">    public void onNativeMessageReceive(final byte[] message) {        String str=null;        try {            str = new String(message, &quot;utf-8&quot;);        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }        Log.i(&quot;NDKManager&quot;,&quot;这是来自ndkmanger的信息&quot; + str);    }</code></pre><p>附件：<br><a href="https://github.com/loongX/NDKSamples/tree/master/NDK-DynamicRegistration" target="_blank" rel="noopener">demo源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的ssh配置和使用</title>
      <link href="/2020/01/05/git-ssh-config/"/>
      <url>/2020/01/05/git-ssh-config/</url>
      
        <content type="html"><![CDATA[<h3 id="一、秘钥生成"><a href="#一、秘钥生成" class="headerlink" title="一、秘钥生成"></a>一、秘钥生成</h3><p>我是在Windows的gitbase里面操作的。<br>生成秘钥：<br>$ ssh-keygen -t rsa -f sample<br>t 为密码类型<br>f 为生成的秘钥文件名称<br>回车键后会让你输入密码，你可以不输，直接按回车到下一步。<br>ssh-keygen -t rsa -C “<a href="mailto:your_email@youremail.com">your_email@youremail.com</a>“<br>有些为了方便识别，会以自己的邮箱做标记。<br>这个是命令输入去执行的结果：</p><pre><code>$ ssh-keygen -t rsa -f sampleGenerating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in sample.Your public key has been saved in sample.pub.The key fingerprint is:SHA256:d1TDf+SYS8BADB4MvGO3yXvdIy6IJsMgncOBSsO4BqE admin@DESKTOPThe key&#39;s randomart image is:+---[RSA 2048]----+|     ..oo+oo .o  ||.     ..... o....||+o     ..   .. * ||E+.   + .  .  + +||++.o . +So. .. ..||+.*     +. .  .  ||.. +   . o . .   ||    + o o o o o  ||     +   . o.. . |+----[SHA256]-----+</code></pre><p>在电脑C:\Users\yourname.ssh会生成对应的私钥和公钥。外来的私钥也可以放这里。<br>如果你没加名称会生成默认名字：id_rsa和id_rsa.pub。id_rsa为私钥，id_rsa.pub为公钥。打开它，里面是一段字符。<br>在本例里会生成sample_rsa和sample.pub<br>$ cd ~/.ssh<br>进入文件夹可以查看</p><p>私钥保存在您的电脑上，公钥交添加到服务器上。<br>用户必须拥有与服务器公钥所配对的私钥，才能访问服务器上的代码库。<br>下面罗列的是ssh-keygen的各个参数的作用</p><pre><code>usage: ssh-keygen [options]Options:  -A          Generate non-existent host keys for all key types.  -a number   Number of KDF rounds for new key format or moduli primality tests.  -B          Show bubblebabble digest of key file.  -b bits     Number of bits in the key to create.  -C comment  Provide new comment.  -c          Change comment in private and public key files.  -D pkcs11   Download public key from pkcs11 token.  -e          Export OpenSSH to foreign format key file.  -F hostname Find hostname in known hosts file.  -f filename Filename of the key file.  -G file     Generate candidates for DH-GEX moduli.  -g          Use generic DNS resource record format.  -H          Hash names in known_hosts file.  -h          Generate host certificate instead of a user certificate.  -I key_id   Key identifier to include in certificate.  -i          Import foreign format to OpenSSH key file.  -J number   Screen this number of moduli lines.  -j number   Start screening moduli at specified line.  -K checkpt  Write checkpoints to this file.  -k          Generate a KRL file.  -L          Print the contents of a certificate.  -l          Show fingerprint of key file.  -M memory   Amount of memory (MB) to use for generating DH-GEX moduli.  -m key_fmt  Conversion format for -e/-i (PEM|PKCS8|RFC4716).  -N phrase   Provide new passphrase.  -n name,... User/host principal names to include in certificate  -O option   Specify a certificate option.  -o          Enforce new private key format.  -P phrase   Provide old passphrase.  -p          Change passphrase of private key file.  -Q          Test whether key(s) are revoked in KRL.  -q          Quiet.  -R hostname Remove host from known_hosts file.  -r hostname Print DNS resource record.  -S start    Start point (hex) for generating DH-GEX moduli.  -s ca_key   Certify keys with CA key.  -T file     Screen candidates for DH-GEX moduli.  -t type     Specify type of key to create.  -u          Update KRL rather than creating a new one.  -V from:to  Specify certificate validity interval.  -v          Verbose.  -W gen      Generator to use for generating DH-GEX moduli.  -y          Read private key file and print public key.  -Z cipher   Specify a cipher for new private key format.  -z serial   Specify a serial number.</code></pre><h3 id="二、放秘钥到服务器上"><a href="#二、放秘钥到服务器上" class="headerlink" title="二、放秘钥到服务器上"></a>二、放秘钥到服务器上</h3><h4 id="1-GitHub服务器"><a href="#1-GitHub服务器" class="headerlink" title="1.GitHub服务器"></a>1.GitHub服务器</h4><p>路径：settings——SSH and GPS keys里面new一个ssh key<br>把对应的公钥（sample.pub）放上去（把文件里的字符复制进去）。<br><img src="http://img.blog.csdn.net/20170913235405697" alt="GitHub_ssh"><br>这时，你已经可以用ssh获取别人的项目代码了<br>获取源码：<br><code>$ git clone git@github.com:username/gitproj.git</code></p><h4 id="2-配置git服务器"><a href="#2-配置git服务器" class="headerlink" title="2.配置git服务器"></a>2.配置git服务器</h4><p>其实就是放了一个远程仓在服务器上。<br>ubuntu上安装git</p><pre><code> sudo apt-get install git</code></pre><p>centos上安装git</p><pre><code>yum install -y git</code></pre><p>创建用户git</p><pre><code>adduser git</code></pre><p>我这里用的是centos<br>进入git用户</p><pre><code>su git</code></pre><p>创建秘钥</p><pre><code> ssh-keygen -t rsa -f ~/.ssh/aliyun</code></pre><p>私钥自行保存。</p><p>创建authorized_keys文件保存公钥</p><pre><code>mkdir .sshchmod 700 ~/.sshtouch ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keyscat ~/.ssh/aliyun.pub &gt;&gt; ~/.ssh/authorized_keys </code></pre><p>出于安全考虑，创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p><pre><code>git:x:1000:1000::/home/git:/bin/bash</code></pre><p>改为</p><pre><code>git:x:1000:1000::/home/git:/usr/bin/git-shell</code></pre><p><strong>测试</strong></p><pre><code> mkdir ~/gitrepo cd ~/gitrepo git init --bare sample.git ##把仓库所属用户改为git chown -R git:git sample.git</code></pre><p>pc端上<br>配置pc端的私钥，放在<del>/.ssh文件夹下面，如有需要可以再配置一个config文件同样放在</del>/.ssh文件夹下面，config文件配置见下文。</p><p>客户端验证</p><pre><code>  git clone git@aliyun-git:gitrepo/sample.git  cd sample  touch a.txt  git add a.txt  git commit -m &quot;init commit&quot;   git push origin master</code></pre><p>这里aliyun-get是域名，更多详细请看下面的config配置。执行到这一步基本ok了。</p><h4 id="3-多服务器ssh"><a href="#3-多服务器ssh" class="headerlink" title="3.多服务器ssh"></a>3.多服务器ssh</h4><p>如果有多台服务器上怎么分别对应不同秘钥呢？你需要配置一个config文件在~/.ssh里面<br>里面写有各个服务器的配置清单。<br>~/.ssh/config</p><pre><code class="shell">Host github.com  HostName        github.com  User            git  IdentityFile    ~/.ssh/id_rsa_githubhost aliyun-git  port 22  compression yes  hostname 192.168.1.120  user git  identityfile ~/.ssh/aliyun</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized</title>
      <link href="/2020/01/05/synchronized/"/>
      <url>/2020/01/05/synchronized/</url>
      
        <content type="html"><![CDATA[<p>一个对象对应一把锁，要线程同步需要两者同步为同一对象。在该问题中，synchronized修饰pubulic方法中没有具体的参数默认的锁为this，即是当前实例对象。在创建过程中创建的是两个不同对象，对应两把不同的锁。由于调用时由于用的不是同一个锁，所以不能线程同步。<br>synchronized修饰的静态方法，能构成线程同步。静态方法加的锁为类对象的锁。由于静态方法具有全局唯一性，调用的时候调用的是同一对象，同一把锁，所以能线程同步。<br>synchronized修饰代码块有两种锁，一种是对象锁，另外一种是类锁。或者叫实例锁，全局锁。如果采用的是对象锁，需要对象为同一对象才能构成线程同步。如果用的是类锁，而类锁在虚拟机中具有唯一性，自然能构成线程同步。</p><h3 id="1-用在对象"><a href="#1-用在对象" class="headerlink" title="1. 用在对象"></a>1. 用在对象</h3><pre><code class="java">    Lock LOCK = new Lock();    /**     * 用在对象     */    private void synchronizedInstance() {        synchronized (LOCK) {            System.out.println(&quot;synchronizedInstance&quot;);            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }</code></pre><p>Java</p><p>以LOCK 为对象锁了。</p><pre><code class="java">    /**     * 用在this     */    private void synchronizedThis() {        synchronized (this) {            System.out.println(&quot;synchronizedThis&quot;);            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }</code></pre><p>Java</p><p>当前实例为锁。<br>对象锁，只有获取当前对象才能进入该方法里面。synchronized methods(){} 与synchronized（this）{}之间没有什么区别。</p><p>私有锁，在类内部声明一个私有属性如private Object lock，在需要加锁的同步块使用 synchronized(lock）。<br>使用私有锁可以减小锁的细粒度，减少由锁产生的开销。私有锁其实也是对象锁的一种。<br>私有锁还可以这样用：用私有锁实现的等待/通知机制。</p><pre><code class="java">Object lock = new Object();// 由等待方线程实现synchronized (lock) {    while (条件不满足) {       lock.wait();   }}// 由通知方线程实现synchronized (lock) {   条件发生改变   lock.notify();}</code></pre><p>Java</p><h3 id="2-用在方法里"><a href="#2-用在方法里" class="headerlink" title="2. 用在方法里"></a>2. 用在方法里</h3><pre><code class="java">    /**     * 用在普通方法     */    private synchronized void synchronizedMethod() {        System.out.println(&quot;synchronizedMethod&quot;);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }</code></pre><p>Java</p><p>如果不是单例，同步方法锁将失效。实际上是当前实例作为锁。</p><pre><code class="java">    /**     * 用在静态方法     */    private synchronized static void synchronizedStaticMethod() {        System.out.println(&quot;synchronizedStaticMethod&quot;);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }</code></pre><p>Java</p><p>静态方法具有全局唯一性，类级别的锁，作为锁线程安全。</p><h3 id="3-用在类里"><a href="#3-用在类里" class="headerlink" title="3. 用在类里"></a>3. 用在类里</h3><pre><code class="java">    /**     * 用在类     */    private void synchronizedClass() {        synchronized (Sync.class) {            System.out.println(&quot;synchronizedClass&quot;);            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * 用在类     */    private void synchronizedGetClass() {        synchronized (this.getClass()) {            System.out.println(&quot;synchronizedGetClass&quot;);            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }</code></pre><p>Java</p><p>两个都是类级锁，线程安全。<br>类锁：使用 synchronized 修饰静态的方法以及 synchronized(class) 同步代码块使用的锁是类锁。<br>对象锁：使用 synchronized 修饰非静态的方法以及 synchronized(this) 同步代码块使用的锁是对象锁。</p><p>类锁和对对象锁不相互阻塞，相同的类锁或相同的实例锁相互阻塞。方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。保证了同一时刻只有一个线程可执行，从而有效的避免了类成员变量的访问冲突。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rxjava2源码分析</title>
      <link href="/2018/06/13/Rxjava2/"/>
      <url>/2018/06/13/Rxjava2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将讲述Rxjava的相关应用和原理，包括基本原理，操作符，线程调用。</p><a id="more"></a><h2 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h2><p>本文解读是rxjava的2.1.0版本，对应的rxandroid版本为2.0.1。<br>先看看基本用法</p><pre><code class="java">  Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {                e.onNext(1);                e.onNext(2);                e.onNext(3);            }        }).subscribe(new Consumer&lt;String&gt;() {            @Override            public void accept(@NonNull String s) throws Exception {                mRxOperatorsText.append(&quot;accept : &quot; + s +&quot;\n&quot;);                Log.e(TAG, &quot;accept : &quot; + s +&quot;\n&quot; );            }        });</code></pre><h2 id="2、原理探究"><a href="#2、原理探究" class="headerlink" title="2、原理探究"></a>2、原理探究</h2><p>Rxjava主要要素是Observable(被观察者)、Observer(观察者)、subscribe(订阅)和事件。理解这些我们接下来往下看。</p><h3 id="2-1-Observable-create"><a href="#2-1-Observable-create" class="headerlink" title="2.1 Observable.create"></a>2.1 Observable.create</h3><p>跟踪Observable.create</p><pre><code>  @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) {        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);        return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));    }</code></pre><p>传入的是ObservableOnSubscribe类型对象，方法的返回值是调用RxJavaPlugins.onAssembly()</p><pre><code>public interface ObservableOnSubscribe&lt;T&gt; {    void subscribe(@NonNull ObservableEmitter&lt;T&gt; e) throws Exception;}</code></pre><h4 id="onAssembly"><a href="#onAssembly" class="headerlink" title="onAssembly"></a>onAssembly</h4><p>在RxJavaPlugins里面看到</p><pre><code class="Java">@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })    @NonNull    public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) {        Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly;//1        if (f != null) {            return apply(f, source); //2        }        return source;//3    }</code></pre><p>在这里可以看出RxJavaPlugin的作用是方便测试和追踪。可以配合instanceof 等等替换某些你想追踪的Obseravble/Observer/Scheduler等等 。你想想onObservableAssembly不为null的情形。</p><h4 id="1-onObservableAssembly"><a href="#1-onObservableAssembly" class="headerlink" title="//1 onObservableAssembly"></a>//1 onObservableAssembly</h4><p> onObservableAssembly是个对象属性，你可以set和get来控制你的对象，主要是用来测试用的。由于没set该对象，此时的f为null，所以返回 source，也就是上面的基本用法里面new 出来的ObservableOnSubscribe对象</p><pre><code>    static volatile Function&lt;? super Observable, ? extends Observable&gt; onObservableAssembly;</code></pre><p>Function类只有一个方法</p><pre><code>public interface Function&lt;T, R&gt; {    @NonNull    R apply(@NonNull T t) throws Exception;}</code></pre><p>接下来看看ObservableCreate里面有什么</p><pre><code>public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; {    final ObservableOnSubscribe&lt;T&gt; source;    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {        this.source = source;    }    @Override    protected void subscribeActual(Observer&lt;? super T&gt; observer) {        CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);        observer.onSubscribe(parent);        try {            source.subscribe(parent);        } catch (Throwable ex) {            Exceptions.throwIfFatal(ex);            parent.onError(ex);        }    }    ......}</code></pre><p><strong><em>请记住这个subscribeActual和这个ObservableCreate，下面会用到。</em></strong></p><h3 id="2-2-observable-subscribe-consumer"><a href="#2-2-observable-subscribe-consumer" class="headerlink" title="2.2 observable.subscribe(consumer)"></a>2.2 observable.subscribe(consumer)</h3><p>下面是订阅的环节。</p><pre><code>public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) {        return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());    }</code></pre><p>往下追</p><pre><code>public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,            Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) {        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);        LambdaObserver&lt;T&gt; ls = new LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe);//1        subscribe(ls);//2        return ls;    }</code></pre><h4 id="1-LambdaObserver"><a href="#1-LambdaObserver" class="headerlink" title="//1 LambdaObserver"></a>//1 LambdaObserver</h4><p>这里新建了一个LambdaObserver类型的对象，把传入的参数转换了。</p><pre><code>public final class LambdaObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable {    private static final long serialVersionUID = -7251123623727029452L;    final Consumer&lt;? super T&gt; onNext;    final Consumer&lt;? super Throwable&gt; onError;    final Action onComplete;    final Consumer&lt;? super Disposable&gt; onSubscribe;    public LambdaObserver(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,            Action onComplete,            Consumer&lt;? super Disposable&gt; onSubscribe) {        super();        this.onNext = onNext;        this.onError = onError;        this.onComplete = onComplete;        this.onSubscribe = onSubscribe;    }    @Override    public void onSubscribe(Disposable s) {        if (DisposableHelper.setOnce(this, s)) {            try {                onSubscribe.accept(this);            } catch (Throwable ex) {                Exceptions.throwIfFatal(ex);                s.dispose();                onError(ex);            }        }    }    @Override    public void onNext(T t) {        if (!isDisposed()) {            try {                onNext.accept(t);            } catch (Throwable e) {                Exceptions.throwIfFatal(e);                get().dispose();                onError(e);            }        }    }     @Override    public void onError(Throwable t) {        if (!isDisposed()) {            lazySet(DisposableHelper.DISPOSED);            try {                onError.accept(t);            } catch (Throwable e) {                Exceptions.throwIfFatal(e);                RxJavaPlugins.onError(new CompositeException(t, e));            }        }    }    @Override    public void onComplete() {        if (!isDisposed()) {            lazySet(DisposableHelper.DISPOSED);            try {                onComplete.run();            } catch (Throwable e) {                Exceptions.throwIfFatal(e);                RxJavaPlugins.onError(e);            }        }    }    @Override    public void dispose() {        DisposableHelper.dispose(this);    }    @Override    public boolean isDisposed() {        return get() == DisposableHelper.DISPOSED;    }}</code></pre><p>这里可以看得出LambdaObserver是封装了一层，用来隔绝参数用。</p><h4 id="2-subscribe-ls"><a href="#2-subscribe-ls" class="headerlink" title="//2  subscribe(ls)"></a>//2  subscribe(ls)</h4><pre><code>public abstract class Observable&lt;T&gt; implements ObservableSource&lt;T&gt; {...... public final void subscribe(Observer&lt;? super T&gt; observer) {        ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);        try {            observer = RxJavaPlugins.onSubscribe(this, observer); //3            ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;);            subscribeActual(observer); //4        } catch (NullPointerException e) { // NOPMD            throw e;        } catch (Throwable e) {            Exceptions.throwIfFatal(e);            // can&#39;t call onError because no way to know if a Disposable has been set or not            // can&#39;t call onSubscribe because the call might have set a Subscription already            RxJavaPlugins.onError(e);            NullPointerException npe = new NullPointerException(&quot;Actually not, but can&#39;t throw other exceptions due to RS&quot;);            npe.initCause(e);            throw npe;        }    }protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);......</code></pre><h4 id="3-RxJavaPlugins-onSubscribe"><a href="#3-RxJavaPlugins-onSubscribe" class="headerlink" title="//3 RxJavaPlugins.onSubscribe"></a>//3 RxJavaPlugins.onSubscribe</h4><pre><code> public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) {        BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe;        if (f != null) {            return apply(f, source, observer);        }        return observer;    }</code></pre><p>这里同样只原路返回observer，因为f为null。</p><h4 id="4-subscribeActual-observer"><a href="#4-subscribeActual-observer" class="headerlink" title="//4 subscribeActual(observer)"></a>//4 subscribeActual(observer)</h4><p>追踪subscribeActual只是一个抽象方法。这时调用的是当初ObservableCreate里面实现的方法。</p><pre><code>    protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);</code></pre><p>ObservableCreate里面的实现</p><pre><code>public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; {    final ObservableOnSubscribe&lt;T&gt; source;    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {        this.source = source;    }    @Override    protected void subscribeActual(Observer&lt;? super T&gt; observer) {        CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); //1        observer.onSubscribe(parent);        try {            source.subscribe(parent);//2        } catch (Throwable ex) {            Exceptions.throwIfFatal(ex);            parent.onError(ex);        }    }</code></pre><h3 id="2-3-subscribeActual"><a href="#2-3-subscribeActual" class="headerlink" title="2.3 subscribeActual"></a>2.3 subscribeActual</h3><h4 id="1-CreateEmitter-lt-T-gt-parent-new-CreateEmitter-lt-T-gt-observer"><a href="#1-CreateEmitter-lt-T-gt-parent-new-CreateEmitter-lt-T-gt-observer" class="headerlink" title="//1 CreateEmitter &lt; T &gt; parent = new CreateEmitter&lt; T &gt;(observer);"></a>//1 CreateEmitter &lt; T &gt; parent = new CreateEmitter&lt; T &gt;(observer);</h4><p>注意上面，observer传入的对象其实就是LambdaObserver。这个CreateEmitter给LambdaObserver封装了一层</p><pre><code>static final class CreateEmitter&lt;T&gt;    extends AtomicReference&lt;Disposable&gt;    implements ObservableEmitter&lt;T&gt;, Disposable {        private static final long serialVersionUID = -3434801548987643227L;        final Observer&lt;? super T&gt; observer;        CreateEmitter(Observer&lt;? super T&gt; observer) {            this.observer = observer;        }         @Override        public void onNext(T t) {            if (t == null) {                onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));                return;            }            if (!isDisposed()) {                observer.onNext(t);            }        }</code></pre><p>observer.onSubscribe(parent);</p><p>这里是传入系统默认值，这里为空，可以认为不起作用。</p><h4 id="2-source-subscribe-parent"><a href="#2-source-subscribe-parent" class="headerlink" title="//2 source.subscribe(parent);"></a>//2 source.subscribe(parent);</h4><p>看到这个source没，这个是source当初new出来的对象并传进来的。</p><pre><code>new ObservableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {                e.onNext(1);                e.onNext(2);                e.onNext(3);            }</code></pre><p>所以在new ObservableOnSubscribe里面的subscribe调用的e.onNext就调用到了后来new Consumer里面的 accept方法。</p><pre><code>new Consumer&lt;String&gt;() {            @Override            public void accept(@NonNull String s) throws Exception {                mRxOperatorsText.append(&quot;accept : &quot; + s +&quot;\n&quot;);                Log.e(TAG, &quot;accept : &quot; + s +&quot;\n&quot; );            }        }</code></pre><p>这一篇将讲下Rxjava2的操作符。在Rxjava里面最常用的是map操作符，接下来将从map入手分析。</p><h2 id="1-map操作符的基本用法"><a href="#1-map操作符的基本用法" class="headerlink" title="1.map操作符的基本用法"></a>1.map操作符的基本用法</h2><p>这里按照国际惯例，先上map的基本用法。</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {                e.onNext(1);                e.onNext(2);                e.onNext(3);            }        }).map(new Function&lt;Integer, String&gt;() {            @Override            public String apply(@NonNull Integer integer) throws Exception {                return &quot;This is result &quot; + integer;            }        }).subscribe(new Consumer&lt;String&gt;() {            @Override            public void accept(@NonNull String s) throws Exception {                mRxOperatorsText.append(&quot;accept : &quot; + s +&quot;\n&quot;);                Log.e(TAG, &quot;accept : &quot; + s +&quot;\n&quot; );            }        });</code></pre><h2 id="2-map源码跟踪"><a href="#2-map源码跟踪" class="headerlink" title="2.map源码跟踪"></a>2.map源码跟踪</h2><h4 id="2-1-map"><a href="#2-1-map" class="headerlink" title="2.1 map"></a>2.1 map</h4><p>跟踪map进去，进入Observable里面，你会发现同样有RxJavaPlugins.onAssembly这东西。</p><pre><code>public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);        return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));    }</code></pre><p>RxJavaPlugins.onAssembly上文已经说过了，这次主要关注ObservableMap。<code>new ObservableMap&lt;T, R&gt;(this, mapper)</code>里面的this是create返回的Observable对象，mapper是你给的Function对象。</p><h4 id="2-2-ObservableMap"><a href="#2-2-ObservableMap" class="headerlink" title="2.2 ObservableMap"></a>2.2 ObservableMap</h4><pre><code>public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; {    final Function&lt;? super T, ? extends U&gt; function;    public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) {        super(source);        this.function = function;    }    @Override    public void subscribeActual(Observer&lt;? super U&gt; t) {         source.subscribe(new MapObserver&lt;T, U&gt;(t, function));    }    static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; {        final Function&lt;? super T, ? extends U&gt; mapper;        MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) {            super(actual);            this.mapper = mapper;        }        @Override        public void onNext(T t) {            if (done) { //默认done为false，跳过                return;            }            if (sourceMode != NONE) { //默认sourceMode 为0，跳过                actual.onNext(null);                return;            }            U v;            try {                v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);//1            } catch (Throwable ex) {                fail(ex);                return;            }            actual.onNext(v);//2        }        @Override        public int requestFusion(int mode) {            return transitiveBoundaryFusion(mode);        }        @Nullable        @Override        public U poll() throws Exception {            T t = qs.poll();            return t != null ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;) : null;        }    }}</code></pre><h3 id="AbstractObservableWithUpstream"><a href="#AbstractObservableWithUpstream" class="headerlink" title="AbstractObservableWithUpstream"></a>AbstractObservableWithUpstream</h3><p>AbstractObservableWithUpstream是什么？它继承了Observable类，把ObservableSource对象保存了起来。</p><pre><code>abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; {    /** The source consumable Observable. */    protected final ObservableSource&lt;T&gt; source;    /**     * Constructs the ObservableSource with the given consumable.     * @param source the consumable Observable     */    AbstractObservableWithUpstream(ObservableSource&lt;T&gt; source) {        this.source = source;    }    @Override    public final ObservableSource&lt;T&gt; source() {        return source;    }}</code></pre><h4 id="1-mapper-apply-t"><a href="#1-mapper-apply-t" class="headerlink" title="//1 mapper.apply(t)"></a>//1 mapper.apply(t)</h4><p>在ObservableMap里面，subscribeActual，将完成上游Observable的订阅。MapObserver里面的mapper.apply(t)将上游的t转换成下游所需的U。这里怎么变换是你一开始时候就设定好的。这里我们当初传入map里面的Function如下。</p><pre><code>new Function&lt;Integer, String&gt;() {            @Override            public String apply(@NonNull Integer integer) throws Exception {                return &quot;This is result &quot; + integer;            }        }</code></pre><h4 id="2-actual-onNext-v"><a href="#2-actual-onNext-v" class="headerlink" title="//2 actual.onNext(v)"></a>//2 actual.onNext(v)</h4><p><code>actual.onNext(v);</code> 是交接给下游的Observer。actual对应本例就是当初create的对象，执行onNext方法就是执行当初自己定义的操作。</p><pre><code>new Consumer&lt;String&gt;() {            @Override            public void accept(@NonNull String s) throws Exception {                mRxOperatorsText.append(&quot;accept : &quot; + s +&quot;\n&quot;);                Log.e(TAG, &quot;accept : &quot; + s +&quot;\n&quot; );            }        }</code></pre><p>至此，当初的<code>e.onNext(1)</code> 将得到响应。</p><p>总结一下。订阅过程是最后一个Observable往上一个Observable订阅（本例中是MapObserver）。从最后一个Observable里面的subscribe有个subscribeActual方法调用，这个方法会一层层订阅，直至第一个Observable。然后触发第一个Observable的subscribe，这里面会触发数据流操作。在本例中，订阅至到第一个Observable的subscribe实现类，里面的<code>e.onNext(1);</code> 会触发数据一层层往下流，下一个是MapObserver对数据的操作，到最后的Observable。</p><p>Rxjava2里面最惊艳的莫过于线程调度吗，下文将探讨一下线程调度的原理。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><pre><code>Observable.create((ObservableOnSubscribe&lt;Integer&gt;) e -&gt; {         e.onNext(1);         e.onNext(2);         e.onComplete(); })    .subscribeOn(Schedulers.io())    .observeOn(AndroidSchedulers.mainThread())    .subscribe(        i -&gt; System.out.println(&quot;onNext : i= &quot; + i));    }</code></pre><h2 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h2><pre><code> @CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable&lt;T&gt; observeOn(Scheduler scheduler) {        return observeOn(scheduler, false, bufferSize());    }</code></pre><pre><code> @CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);        return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));    }</code></pre><pre><code>@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })    @NonNull    public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) {        Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }</code></pre><pre><code>public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; {    final Scheduler scheduler;    final boolean delayError;    final int bufferSize;    public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) {        super(source);        this.scheduler = scheduler;        this.delayError = delayError;        this.bufferSize = bufferSize;    }    protected void subscribeActual(Observer&lt;? super T&gt; observer) {        if (this.scheduler instanceof TrampolineScheduler) {            this.source.subscribe(observer);        } else {            Worker w = this.scheduler.createWorker();            this.source.subscribe(new ObservableObserveOn.ObserveOnObserver(observer, w, this.delayError, this.bufferSize));        }    }    static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt; implements Observer&lt;T&gt;, Runnable {        private static final long serialVersionUID = 6576896619930983584L;        final Observer&lt;? super T&gt; actual;        final Worker worker;        final boolean delayError;        final int bufferSize;        SimpleQueue&lt;T&gt; queue;        Disposable s;        Throwable error;        volatile boolean done;        volatile boolean cancelled;        int sourceMode;        boolean outputFused;        ObserveOnObserver(Observer&lt;? super T&gt; actual, Worker worker, boolean delayError, int bufferSize) {            this.actual = actual;            this.worker = worker;            this.delayError = delayError;            this.bufferSize = bufferSize;        }        public void onSubscribe(Disposable s) {            if (DisposableHelper.validate(this.s, s)) {                this.s = s;                if (s instanceof QueueDisposable) {                    QueueDisposable&lt;T&gt; qd = (QueueDisposable)s;                    int m = qd.requestFusion(7);                    if (m == 1) {                        this.sourceMode = m;                        this.queue = qd;                        this.done = true;                        this.actual.onSubscribe(this);                        this.schedule();                        return;                    }                    if (m == 2) {                        this.sourceMode = m;                        this.queue = qd;                        this.actual.onSubscribe(this);                        return;                    }                }                this.queue = new SpscLinkedArrayQueue(this.bufferSize);                this.actual.onSubscribe(this);            }        }        public void onNext(T t) {            if (!this.done) {                if (this.sourceMode != 2) {                    this.queue.offer(t);                }                this.schedule();            }        }        public void onError(Throwable t) {            if (this.done) {                RxJavaPlugins.onError(t);            } else {                this.error = t;                this.done = true;                this.schedule();            }        }        public void onComplete() {            if (!this.done) {                this.done = true;                this.schedule();            }        }        public void dispose() {            if (!this.cancelled) {                this.cancelled = true;                this.s.dispose();                this.worker.dispose();                if (this.getAndIncrement() == 0) {                    this.queue.clear();                }            }        }        public boolean isDisposed() {            return this.cancelled;        }        void schedule() {            if (this.getAndIncrement() == 0) {                this.worker.schedule(this);            }        }        void drainNormal() {            int missed = 1;            SimpleQueue&lt;T&gt; q = this.queue;            Observer a = this.actual;            do {                if (this.checkTerminated(this.done, q.isEmpty(), a)) {                    return;                }                while(true) {                    boolean d = this.done;                    Object v;                    try {                        v = q.poll();                    } catch (Throwable var7) {                        Exceptions.throwIfFatal(var7);                        this.s.dispose();                        q.clear();                        a.onError(var7);                        this.worker.dispose();                        return;                    }                    boolean empty = v == null;                    if (this.checkTerminated(d, empty, a)) {                        return;                    }                    if (empty) {                        missed = this.addAndGet(-missed);                        break;                    }                    a.onNext(v);                }            } while(missed != 0);        }        void drainFused() {            int missed = 1;            do {                if (this.cancelled) {                    return;                }                boolean d = this.done;                Throwable ex = this.error;                if (!this.delayError &amp;&amp; d &amp;&amp; ex != null) {                    this.actual.onError(this.error);                    this.worker.dispose();                    return;                }                this.actual.onNext((Object)null);                if (d) {                    ex = this.error;                    if (ex != null) {                        this.actual.onError(ex);                    } else {                        this.actual.onComplete();                    }                    this.worker.dispose();                    return;                }                missed = this.addAndGet(-missed);            } while(missed != 0);        }        public void run() {            if (this.outputFused) {                this.drainFused();            } else {                this.drainNormal();            }        }        boolean checkTerminated(boolean d, boolean empty, Observer&lt;? super T&gt; a) {            if (this.cancelled) {                this.queue.clear();                return true;            } else {                if (d) {                    Throwable e = this.error;                    if (this.delayError) {                        if (empty) {                            if (e != null) {                                a.onError(e);                            } else {                                a.onComplete();                            }                            this.worker.dispose();                            return true;                        }                    } else {                        if (e != null) {                            this.queue.clear();                            a.onError(e);                            this.worker.dispose();                            return true;                        }                        if (empty) {                            a.onComplete();                            this.worker.dispose();                            return true;                        }                    }                }                return false;            }        }        public int requestFusion(int mode) {            if ((mode &amp; 2) != 0) {                this.outputFused = true;                return 2;            } else {                return 0;            }        }        @Nullable        public T poll() throws Exception {            return this.queue.poll();        }        public void clear() {            this.queue.clear();        }        public boolean isEmpty() {            return this.queue.isEmpty();        }    }}</code></pre><pre><code>AndroidSchedulers.mainThread()</code></pre><pre><code>public final class AndroidSchedulers {    private static final class MainHolder {        static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));    }    private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(            new Callable&lt;Scheduler&gt;() {                @Override public Scheduler call() throws Exception {                    return MainHolder.DEFAULT;                }            });    /** A {@link Scheduler} which executes actions on the Android main thread. */    public static Scheduler mainThread() {        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);    }    /** A {@link Scheduler} which executes actions on {@code looper}. */    public static Scheduler from(Looper looper) {        if (looper == null) throw new NullPointerException(&quot;looper == null&quot;);        return new HandlerScheduler(new Handler(looper));    }    private AndroidSchedulers() {        throw new AssertionError(&quot;No instances.&quot;);    }}</code></pre><pre><code>public static Scheduler io() {    return RxJavaPlugins.onIoScheduler(IO);}</code></pre><pre><code>@NonNullpublic static Scheduler onIoScheduler(@NonNull Scheduler defaultScheduler) {    Function&lt;? super Scheduler, ? extends Scheduler&gt; f = onIoHandler;    if (f == null) {        return defaultScheduler;    }    return apply(f, defaultScheduler);}</code></pre><pre><code class="java">public abstract class Scheduler {    /**     * The tolerance for a clock drift in nanoseconds where the periodic scheduler will rebase.     * &lt;p&gt;     * The associated system parameter, {@code rx.scheduler.drift-tolerance}, expects its value in minutes.     */    static final long CLOCK_DRIFT_TOLERANCE_NANOSECONDS;    static {        CLOCK_DRIFT_TOLERANCE_NANOSECONDS = TimeUnit.MINUTES.toNanos(                Long.getLong(&quot;rx2.scheduler.drift-tolerance&quot;, 15));    }    /**     * Returns the clock drift tolerance in nanoseconds.     * &lt;p&gt;Related system property: {@code rx2.scheduler.drift-tolerance} in minutes     * @return the tolerance in nanoseconds     * @since 2.0     */    public static long clockDriftTolerance() {        return CLOCK_DRIFT_TOLERANCE_NANOSECONDS;    }    /**     * Retrieves or creates a new {@link Scheduler.Worker} that represents serial execution of actions.     * &lt;p&gt;     * When work is completed it should be unsubscribed using {@link Scheduler.Worker#dispose()}.     * &lt;p&gt;     * Work on a {@link Scheduler.Worker} is guaranteed to be sequential.     *     * @return a Worker representing a serial queue of actions to be executed     */    @NonNull    public abstract Worker createWorker();    /**     * Returns the &#39;current time&#39; of the Scheduler in the specified time unit.     * @param unit the time unit     * @return the &#39;current time&#39;     * @since 2.0     */    public long now(@NonNull TimeUnit unit) {        return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);    }    /**     * Allows the Scheduler instance to start threads     * and accept tasks on them.     * &lt;p&gt;Implementations should make sure the call is idempotent and thread-safe.     * @since 2.0     */    public void start() {    }    /**     * Instructs the Scheduler instance to stop threads     * and stop accepting tasks on any outstanding Workers.     * &lt;p&gt;Implementations should make sure the call is idempotent and thread-safe.     * @since 2.0     */    public void shutdown() {    }    /**     * Schedules the given task on this scheduler non-delayed execution.     *     * &lt;p&gt;     * This method is safe to be called from multiple threads but there are no     * ordering guarantees between tasks.     *     * @param run the task to execute     *     * @return the Disposable instance that let&#39;s one cancel this particular task.     * @since 2.0     */    @NonNull    public Disposable scheduleDirect(@NonNull Runnable run) {        return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);    }    /**     * Schedules the execution of the given task with the given delay amount.     *     * &lt;p&gt;     * This method is safe to be called from multiple threads but there are no     * ordering guarantees between tasks.     *     * @param run the task to schedule     * @param delay the delay amount, non-positive values indicate non-delayed scheduling     * @param unit the unit of measure of the delay amount     * @return the Disposable that let&#39;s one cancel this particular delayed task.     * @since 2.0     */    @NonNull    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {        final Worker w = createWorker();        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);        DisposeTask task = new DisposeTask(decoratedRun, w);        w.schedule(task, delay, unit);        return task;    }    /**     * Schedules a periodic execution of the given task with the given initial delay and period.     *     * &lt;p&gt;     * This method is safe to be called from multiple threads but there are no     * ordering guarantees between tasks.     *     * &lt;p&gt;     * The periodic execution is at a fixed rate, that is, the first execution will be after the initial     * delay, the second after initialDelay + period, the third after initialDelay + 2 * period, and so on.     *     * @param run the task to schedule     * @param initialDelay the initial delay amount, non-positive values indicate non-delayed scheduling     * @param period the period at which the task should be re-executed     * @param unit the unit of measure of the delay amount     * @return the Disposable that let&#39;s one cancel this particular delayed task.     * @since 2.0     */    @NonNull    public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit) {        final Worker w = createWorker();        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);        PeriodicDirectTask periodicTask = new PeriodicDirectTask(decoratedRun, w);        Disposable d = w.schedulePeriodically(periodicTask, initialDelay, period, unit);        if (d == EmptyDisposable.INSTANCE) {            return d;        }        return periodicTask;    }    /**     * Allows the use of operators for controlling the timing around when     * actions scheduled on workers are actually done. This makes it possible to     * layer additional behavior on this {@link Scheduler}. The only parameter     * is a function that flattens an {@link Flowable} of {@link Flowable}     * of {@link Completable}s into just one {@link Completable}. There must be     * a chain of operators connecting the returned value to the source     * {@link Flowable} otherwise any work scheduled on the returned     * {@link Scheduler} will not be executed.     * &lt;p&gt;     * When {@link Scheduler#createWorker()} is invoked a {@link Flowable} of     * {@link Completable}s is onNext&#39;d to the combinator to be flattened. If     * the inner {@link Flowable} is not immediately subscribed to an calls to     * {@link Worker#schedule} are buffered. Once the {@link Flowable} is     * subscribed to actions are then onNext&#39;d as {@link Completable}s.     * &lt;p&gt;     * Finally the actions scheduled on the parent {@link Scheduler} when the     * inner most {@link Completable}s are subscribed to.     * &lt;p&gt;     * When the {@link Worker} is unsubscribed the {@link Completable} emits an     * onComplete and triggers any behavior in the flattening operator. The     * {@link Flowable} and all {@link Completable}s give to the flattening     * function never onError.     * &lt;p&gt;     * Limit the amount concurrency two at a time without creating a new fix     * size thread pool:     *      * &lt;pre&gt;     * Scheduler limitScheduler = Schedulers.computation().when(workers -&gt; {     *  // use merge max concurrent to limit the number of concurrent     *  // callbacks two at a time     *  return Completable.merge(Flowable.merge(workers), 2);     * });     * &lt;/pre&gt;     * &lt;p&gt;     * This is a slightly different way to limit the concurrency but it has some     * interesting benefits and drawbacks to the method above. It works by     * limited the number of concurrent {@link Worker}s rather than individual     * actions. Generally each {@link Flowable} uses its own {@link Worker}.     * This means that this will essentially limit the number of concurrent     * subscribes. The danger comes from using operators like     * {@link Flowable#zip(org.reactivestreams.Publisher, org.reactivestreams.Publisher, io.reactivex.functions.BiFunction)} where     * subscribing to the first {@link Flowable} could deadlock the     * subscription to the second.     *      * &lt;pre&gt;     * Scheduler limitScheduler = Schedulers.computation().when(workers -&gt; {     *  // use merge max concurrent to limit the number of concurrent     *  // Flowables two at a time     *  return Completable.merge(Flowable.merge(workers, 2));     * });     * &lt;/pre&gt;     *      * Slowing down the rate to no more than than 1 a second. This suffers from     * the same problem as the one above I could find an {@link Flowable}     * operator that limits the rate without dropping the values (aka leaky     * bucket algorithm).     *      * &lt;pre&gt;     * Scheduler slowScheduler = Schedulers.computation().when(workers -&gt; {     *  // use concatenate to make each worker happen one at a time.     *  return Completable.concat(workers.map(actions -&gt; {     *      // delay the starting of the next worker by 1 second.     *      return Completable.merge(actions.delaySubscription(1, TimeUnit.SECONDS));     *  }));     * });     * &lt;/pre&gt;     *      * &lt;p&gt;History: 2.0.1 - experimental     * @param &lt;S&gt; a Scheduler and a Subscription     * @param combine the function that takes a two-level nested Flowable sequence of a Completable and returns     * the Completable that will be subscribed to and should trigger the execution of the scheduled Actions.     * @return the Scheduler with the customized execution behavior     * @since 2.1     */    @SuppressWarnings(&quot;unchecked&quot;)    @NonNull    public &lt;S extends Scheduler &amp; Disposable&gt; S when(@NonNull Function&lt;Flowable&lt;Flowable&lt;Completable&gt;&gt;, Completable&gt; combine) {        return (S) new SchedulerWhen(combine, this);    }    /**     * Sequential Scheduler for executing actions on a single thread or event loop.     * &lt;p&gt;     * Disposing the {@link Worker} cancels all outstanding work and allows resource cleanup.     */    public abstract static class Worker implements Disposable {        /**         * Schedules a Runnable for execution without delay.         *         * &lt;p&gt;The default implementation delegates to {@link #schedule(Runnable, long, TimeUnit)}.         *         * @param run         *            Runnable to schedule         * @return a Disposable to be able to unsubscribe the action (cancel it if not executed)         */        @NonNull        public Disposable schedule(@NonNull Runnable run) {            return schedule(run, 0L, TimeUnit.NANOSECONDS);        }        /**         * Schedules an Runnable for execution at some point in the future.         * &lt;p&gt;         * Note to implementors: non-positive {@code delayTime} should be regarded as non-delayed schedule, i.e.,         * as if the {@link #schedule(Runnable)} was called.         *         * @param run         *            the Runnable to schedule         * @param delay         *            time to wait before executing the action; non-positive values indicate an non-delayed         *            schedule         * @param unit         *            the time unit of {@code delayTime}         * @return a Disposable to be able to unsubscribe the action (cancel it if not executed)         */        @NonNull        public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);        /**         * Schedules a cancelable action to be executed periodically. This default implementation schedules         * recursively and waits for actions to complete (instead of potentially executing long-running actions         * concurrently). Each scheduler that can do periodic scheduling in a better way should override this.         * &lt;p&gt;         * Note to implementors: non-positive {@code initialTime} and {@code period} should be regarded as         * non-delayed scheduling of the first and any subsequent executions.         *         * @param run         *            the Runnable to execute periodically         * @param initialDelay         *            time to wait before executing the action for the first time; non-positive values indicate         *            an non-delayed schedule         * @param period         *            the time interval to wait each time in between executing the action; non-positive values         *            indicate no delay between repeated schedules         * @param unit         *            the time unit of {@code period}         * @return a Disposable to be able to unsubscribe the action (cancel it if not executed)         */        @NonNull        public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) {            final SequentialDisposable first = new SequentialDisposable();            final SequentialDisposable sd = new SequentialDisposable(first);            final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);            final long periodInNanoseconds = unit.toNanos(period);            final long firstNowNanoseconds = now(TimeUnit.NANOSECONDS);            final long firstStartInNanoseconds = firstNowNanoseconds + unit.toNanos(initialDelay);            Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,                    periodInNanoseconds), initialDelay, unit);            if (d == EmptyDisposable.INSTANCE) {                return d;            }            first.replace(d);            return sd;        }        /**         * Returns the &#39;current time&#39; of the Worker in the specified time unit.         * @param unit the time unit         * @return the &#39;current time&#39;         * @since 2.0         */        public long now(@NonNull TimeUnit unit) {            return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);        }        /**         * Holds state and logic to calculate when the next delayed invocation         * of this task has to happen (accounting for clock drifts).         */        final class PeriodicTask implements Runnable {            @NonNull            final Runnable decoratedRun;            @NonNull            final SequentialDisposable sd;            final long periodInNanoseconds;            long count;            long lastNowNanoseconds;            long startInNanoseconds;            PeriodicTask(long firstStartInNanoseconds, @NonNull Runnable decoratedRun,                    long firstNowNanoseconds, @NonNull SequentialDisposable sd, long periodInNanoseconds) {                this.decoratedRun = decoratedRun;                this.sd = sd;                this.periodInNanoseconds = periodInNanoseconds;                lastNowNanoseconds = firstNowNanoseconds;                startInNanoseconds = firstStartInNanoseconds;            }            @Override            public void run() {                decoratedRun.run();                if (!sd.isDisposed()) {                    long nextTick;                    long nowNanoseconds = now(TimeUnit.NANOSECONDS);                    // If the clock moved in a direction quite a bit, rebase the repetition period                    if (nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS &lt; lastNowNanoseconds                            || nowNanoseconds &gt;= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS) {                        nextTick = nowNanoseconds + periodInNanoseconds;                        /*                         * Shift the start point back by the drift as if the whole thing                         * started count periods ago.                         */                        startInNanoseconds = nextTick - (periodInNanoseconds * (++count));                    } else {                        nextTick = startInNanoseconds + (++count * periodInNanoseconds);                    }                    lastNowNanoseconds = nowNanoseconds;                    long delay = nextTick - nowNanoseconds;                    sd.replace(schedule(this, delay, TimeUnit.NANOSECONDS));                }            }        }    }    static class PeriodicDirectTask    implements Runnable, Disposable {        final Runnable run;        @NonNull        final Worker worker;        @NonNull        volatile boolean disposed;        PeriodicDirectTask(@NonNull Runnable run, @NonNull Worker worker) {            this.run = run;            this.worker = worker;        }        @Override        public void run() {            if (!disposed) {                try {                    run.run();                } catch (Throwable ex) {                    Exceptions.throwIfFatal(ex);                    worker.dispose();                    throw ExceptionHelper.wrapOrThrow(ex);                }            }        }        @Override        public void dispose() {            disposed = true;            worker.dispose();        }        @Override        public boolean isDisposed() {            return disposed;        }    }    static final class DisposeTask implements Runnable, Disposable {        final Runnable decoratedRun;        final Worker w;        Thread runner;        DisposeTask(Runnable decoratedRun, Worker w) {            this.decoratedRun = decoratedRun;            this.w = w;        }        @Override        public void run() {            runner = Thread.currentThread();            try {                decoratedRun.run();            } finally {                dispose();                runner = null;            }        }        @Override        public void dispose() {            if (runner == Thread.currentThread() &amp;&amp; w instanceof NewThreadWorker) {                ((NewThreadWorker)w).shutdown();            } else {                w.dispose();            }        }        @Override        public boolean isDisposed() {            return w.isDisposed();        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android注解</title>
      <link href="/2017/11/06/Annotation/"/>
      <url>/2017/11/06/Annotation/</url>
      
        <content type="html"><![CDATA[<p>Android里面的注解一般有两种，一种运行时注解，另外一种是编译时注解。运行时注解是基于反射原理的，编译时注解这个就多点，常见的是基于apt的代码生成。反射，会在运行时候在对应的位置插入对应的操作；而编译时注解会在编译时候生成对应的代码进行编译。对于运行性能来说，反射更耗性能。本章将说下Android的注解。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从下面这张图可以看到Java注解的结构分支。<br><img src="/images/Java%E6%B3%A8%E8%A7%A3.jpg" alt="Java注解"> </p><p> Java注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<br> 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。</p><p> （1）元注解<br>元注解是指注解的注解，负责注解其他的注解。有@Retention @Target @Document @Inherited这四种。</p><p>（2）@Retention: 定义注解的保留策略<br>@Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含<br>@Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，<br>@Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到</p><p>（3）@Target：定义注解的作用目标<br>其定义的源码为：<br>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //方法参数<br>@Target(ElementType.CONSTRUCTOR)  //构造函数<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包   </p><p>（4）@Document：说明该注解将被包含在javadoc中</p><p>（5）@Inherited：允许子类可以继承父类中的该注解</p><h2 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h4><p>下面将用注解实现了一个findViewById功能。</p><h5 id="（1）-定义注解"><a href="#（1）-定义注解" class="headerlink" title="（1） 定义注解"></a>（1） 定义注解</h5><pre><code class="Java">package com.example.basedemo.annotation.diy;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface ViewInject {    int value();    /* parent view id */    int parentId() default 0;}</code></pre><h5 id="（2）-定义注解处理"><a href="#（2）-定义注解处理" class="headerlink" title="（2） 定义注解处理"></a>（2） 定义注解处理</h5><pre><code class="Java">public class ViewUtils {    private ViewUtils() {    }    public static void inject(Activity activity) {        injectObject(activity, new ViewFinder(activity));    }    @SuppressWarnings(&quot;ConstantConditions&quot;)    private static void injectObject(Object handler, ViewFinder finder) {        Class&lt;?&gt; handlerType = handler.getClass();        // inject view        Field[] fields = handlerType.getDeclaredFields();        if (fields != null &amp;&amp; fields.length &gt; 0) {            for (Field field : fields) {                ViewInject viewInject = field.getAnnotation(ViewInject.class);                if (viewInject != null) {                    try {                        View view = finder.findViewById(viewInject.value(), viewInject.parentId());                        if (view != null) {                            field.setAccessible(true);                            field.set(handler, view);                        }                    } catch (Throwable e) {                        e.printStackTrace();                    }                }            }        }    }}</code></pre><pre><code class="Java">public class ViewFinder {    private Activity activity;    public ViewFinder(Activity activity) {        this.activity = activity;    }    public View findViewById(int id) {        return  activity.findViewById(id);    }    public View findViewById(int id, int pid) {        View pView = null;        if (pid &gt; 0) {            pView = this.findViewById(pid);        }        View view = null;        if (pView != null) {            view = pView.findViewById(id);        } else {            view = this.findViewById(id);        }        return view;    }}</code></pre><h5 id="（3）-注解的使用"><a href="#（3）-注解的使用" class="headerlink" title="（3） 注解的使用"></a>（3） 注解的使用</h5><p>这是activity里面的调用</p><pre><code class="Java">public class DIYAnnotationActivity extends AppCompatActivity {    @ViewInject(R.id.textView)    private TextView textView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_annotation);        //调用        ViewUtils.inject(this);        textView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                textView.setText(&quot;成功了！&quot;);            }        });    }}</code></pre><p>布局文件比较简单就不罗列了。这里可以看出，反射用法过程是：定义注解–定义注解处理方法–调用。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>下面将在原有的基础上添加点击事件注解。</p><h5 id="（1）定义注解"><a href="#（1）定义注解" class="headerlink" title="（1）定义注解"></a>（1）定义注解</h5><p>定义一个onclick声明</p><pre><code class="Java">package com.example.basedemo.annotation.diy;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface OnClick {    int[] value();    int[] parentId() default 0;}</code></pre><h5 id="（2）定义注解处理"><a href="#（2）定义注解处理" class="headerlink" title="（2）定义注解处理"></a>（2）定义注解处理</h5><p>然后在ViewUtils里声明多一个方法。这是用了Java的动态代理方法。</p><pre><code class="Java">public class ViewUtils {    ......省略    public static void inject(Activity activity) {        injectObject(activity, new ViewFinder(activity));        injectEvent(activity);    }    ......省略    private static void injectEvent(final Activity activity) {        Class&lt;? extends Activity&gt; clazz = activity.getClass();        Method[] methods = clazz.getDeclaredMethods();        for (final Method methodY : methods) {            OnClick click = methodY.getAnnotation(OnClick.class);            if (click != null) {                int[] viewId = click.value();                methodY.setAccessible(true);                Object listener = Proxy.newProxyInstance(View.OnClickListener.class.getClassLoader(),                        new Class[]{View.OnClickListener.class}, new InvocationHandler() {                            @Override                            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                                return methodY.invoke(activity, args);                            }                        });                try {                    for (int id : viewId) {                        View v = activity.findViewById(id);                        Method setClickListener = v.getClass().getMethod(&quot;setOnClickListener&quot;, View.OnClickListener.class);                        setClickListener.invoke(v, listener);                    }                } catch (Exception e) {                    e.printStackTrace();                }            }        }    } }</code></pre><h5 id="（3）在activity里面调用"><a href="#（3）在activity里面调用" class="headerlink" title="（3）在activity里面调用"></a>（3）在activity里面调用</h5><pre><code class="Java">    @OnClick(R.id.tb_2)    public void onClick(View v) {        textView.setText(&quot;你按了button2&quot;);    }</code></pre><h4 id="方法注解"><a href="#方法注解" class="headerlink" title="方法注解"></a>方法注解</h4><p>给setcontentview注解</p><h5 id="（1）定义注解-1"><a href="#（1）定义注解-1" class="headerlink" title="（1）定义注解"></a>（1）定义注解</h5><pre><code class="Java">package com.example.basedemo.annotation.diy;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ContentView {    int value();}</code></pre><h5 id="（2）注解处理"><a href="#（2）注解处理" class="headerlink" title="（2）注解处理"></a>（2）注解处理</h5><pre><code class="Java">    public static void injectContentView(Object handler){        Class&lt;?&gt; handlerType = handler.getClass();        // inject ContentView        ContentView contentView = handlerType.getAnnotation(ContentView.class);        if (contentView != null) {            try {                Method setContentViewMethod = handlerType.getMethod(&quot;setContentView&quot;, int.class);                setContentViewMethod.invoke(handler, contentView.value());            } catch (Throwable e) {                e.printStackTrace();            }        }    }</code></pre><h5 id="（3）调用"><a href="#（3）调用" class="headerlink" title="（3）调用"></a>（3）调用</h5><p>activity里面调用</p><pre><code class="Java">@ContentView(R.layout.activity_annotation)public class DIYAnnotationActivity extends AppCompatActivity {    @ViewInject(R.id.textView)    private TextView textView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);//        setContentView(R.layout.activity_annotation);        ViewUtils.injectContentView(this);        ViewUtils.inject(this);        textView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                textView.setText(&quot;成功了！&quot;);            }        });    }    @OnClick(R.id.tb_2)    public void onClick(View v) {        textView.setText(&quot;你按了button2&quot;);    }}</code></pre><h2 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>APT(annotation processing tool) 是一种处理注释的工具,它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。Annotation处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件,APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件.简化工作量。但是在java8 开始apt就被移除了，使用JSR 269 API（Pluggable Annotation Processing API） 来处理注解，所以要用APT要定义编译的jdk版本为1.7。</p><p>实现一个apt工具分两步，一是实现处理器（实现接口AnnotationProcessor），二是实现返回此处理器的工厂类（实现接口AnnotationProcessorFactory）。</p><p>APT首先检测源代码文件中哪些annotation存在。然后APT将查找我们编写的annotation processor factories类，并且要求factories类提供处理源文件中所涉及的annotation的annotation processor。接下来，一个合适的annotation processors将被执行，如果在processors生成源代码文件时，该文件中含有annotation，则APT将重复上面的过程直到没有新文件生成。整个过程APT就像一个在编译时处理annotation的javac.</p><p>编写一个annotation processors需要使用java lib目录中的tools.jar提供的以下4个包：<br><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/apt/" target="_blank" rel="noopener">apt相关资料</a></p><ul><li><p>com.sun.mirror.apt: 和APT交互的接口；</p></li><li><p>com.sun.mirror.declaration: 用于模式化类成员、类方法、类声明的接口；</p></li><li><p>com.sun.mirror.type: 用于模式化源代码中类型的接口；</p></li><li><p>com.sun.mirror.util: 提供了用于处理类型和声明的一些工具。</p></li></ul><ul><li><p>javax.annotation.processing.SupportedAnnotationTypes：这个注解用来注册注解处理器要处理的注解类型。有效值为完全限定名（就是带所在包名和路径的类全名）-通配符（此次英语原文为Wildcards,就是？这个符号代表的类型。比如说List&lt;? extends String,想要深入了解，可以看一下这里）也可以。</p></li><li><p>javax.annotation.processing.SupportedSourceVersion:这是用来注册注解处理器要处理的源代码版本。</p></li><li><p>javax.annotation.processing.SupportedOptions:这个注解用来注册可能通过命令行传递给处理器的操作选项。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反馈式学习</title>
      <link href="/2017/09/30/StudyByFeedback/"/>
      <url>/2017/09/30/StudyByFeedback/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>本篇文章将讲述我自己的学习方法——反馈式学习。每个人对学习方法都有不同的理解，可能某个人对某种学习方式有较深刻的感触，而其他人却不感兴趣。这可能是学习方式没能勾起你的生活体验。但如果你深究到底，你可能会发现它们的核心原理是一样的。同样，这篇文章里面的学习形式其实并不重要，最主要的还是其原理。希望你能根据其背后原理整出自己的学习方法。</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="一、反馈式学习"><a href="#一、反馈式学习" class="headerlink" title="一、反馈式学习"></a>一、反馈式学习</h2><p>反馈式学习是以反馈为根本的学习方式，一切反馈都可以当作一种学习。你首先搭建好一个有信息反馈的环境，然后在里面探索，在探索过程中逐渐形成知识体系。此时的你犹如一个新奇的小孩走进了糖果屋一样，到处探索，无拘无束，你想要的东西都能从探索中获取到。</p><p>反馈环境可以各式各样的，可以是搜索引擎，可以是调试环境，可以是书籍，也可以是同行专家。你就假定你的反馈环境可以给你各种想要的答案。以搜索引擎作为反馈来源的话，你有什么不懂的概念可以直接用搜索引擎搜索。如果书是你的信息来源，你有什么疑惑就在书上找答案。在调试的时候，你有什么想法你可以放到调试环境里试，它会告诉你正确与否。各种反馈方式其实并不孤立的，你可以把它们组合在一起用。不懂的问题找书，书上没有答案就上网查，百度不到就谷歌搜索，其他博客找不到就官网找。从质量来说，它们的质量从低到高为：网站博客&lt;书籍&lt;官网&lt;源码（这里并不全罗列）。你尽量挑选质量高的信息来源，这样保证了信息的可靠程度。</p><p>反馈式学习本质是自身和反馈源形成反馈回路来修正认知偏差。自身是指现在已有的认知框架，反馈源是对照组。当自身的认知和反馈源存在误差时候，根据反馈来修正偏差。当你在反馈环境里面探索中，错误的认知会被纠正，正确的会被夯实。 </p><p>虽然你知道本质，但在实际操作上不好操作，你会用到另外一个反馈回路：“问题——答案”反馈回路。在考驾照时，有个科目一，是考驾驶的相关规则的，大抵上是在电脑上完成相关的题目的作答。这时候你能获取到到的资料是题库里面的题目。即使刚开始什么都不懂，随着做题，做着做着自己就会了。这个从不会到学会的过程是一个很奇妙的感觉。这时题目和答案构成了一个反馈回路。不断做题的过程中，其实你也是不断修正自己认知。做对做错，答案会告诉你结果。哪怕做的时候没有一点概念，看答案你也能从中学到理论。相比比于你直接看理论，自己做题探索得来的则更加深刻。</p><p>问题和答案的关系将会像下面这图一样。</p><p><img src="/images/%E5%8F%8D%E9%A6%88%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%BC%8F.jpg" alt="问题-答案"></p><p>在这里，问题不单单指的是问题，它更代表着一种搓揉机制；答案也同样不单指答案，它是一种学习机制。搓揉机制你想方设法去产生问题的地方，是你学习的方向。你可以复盘，用现在的认知和过去的认知相对比，搓出偏差来。你可以自己对自己提出各种问题。你也可以用下面将要说的框架理论来指导和扩展自己的认知圈。总之，任何你想要提出的问题都尽情地在这里提出。学习机制是你根据问题然后在环境里探索得出的答案。你假定反馈环境是能给你带来任何你想要的答案。你所要做的是在你环境里找到那个答案。搓揉机制产生问题，你就带着问题到环境里探索得到答案返回，然后搓揉机制再根据这答案的基础上继续产生问题，一圈圈扩展。</p><p>反馈式学习是把你放在一个有反馈的容器里反馈。它分为两个观点：结构化，容器化。结构化是把知识整理方法，容器化是用来学习的环境，结构化也细分目标，引导你在容器内前进。下面将细将这两点。</p><h2 id="二、结构化"><a href="#二、结构化" class="headerlink" title="二、结构化"></a>二、结构化</h2><p>结构化概括来说是：自上而下套框架，自下而上提炼框架。主要是用来作为产生学习方向和提炼知识架构用的。</p><h3 id="2-1-自上而下套框架"><a href="#2-1-自上而下套框架" class="headerlink" title="2.1 自上而下套框架"></a>2.1 自上而下套框架</h3><p>狭义的框架指的是知识体系，广义的框架指的是计划。如果你知道一个知识点的知识体系，你要学这个知识，那么这个知识体系架构就变成你要走的路。知识体系上面的每一个节点都是你的计划里面的目标。你一步一脚印，按顺序一个个实现，最终会到达你想去的目的地。但现实情况并没有这么理想，随着时间推移，你的认知会逐渐扩大，你的所认识的知识体系也会有所变化。这就有点抓狂了，有种计划赶不上变化的感觉了。但你也不必慌。一般来说你前一次的框架会是后一次的框架扩展的枝干。你每次掌握住当前层次的大方向，然后在枝节方面再细节化行了。</p><p>下面说个实际的例子。如果让你学一个你从来没接触过的知识的时候，你会怎么做？你可以像下面的这么做。首先，你利用搜索引擎了解到相关概念，了解相关的术语。然后找一个简单的Demo来实现。这个Demo最好是有详细的讲解，这样方便理解。接着，你就在这个Demo上添加其他的功能，丰富这方面的知识。这里你如果能有同行专家来交流就更好了，有人指导还是学得还是比较快的。到最后，为了完善这个知识体系，你需上官网看最官方最权威最全面的解读，如有源码可以直接看源码。</p><p><img src="/images/%E5%8F%8D%E9%A6%88%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B.jpg" alt="反馈式学习-扩展过程"></p><p>这个学习的过程发生了什么呢？当你刚开始用搜索搜索概念做Demo的时候，你会在心里会形成一个初步的认识。这个初步的认知是颗种子，它会指导后面你要去了解的方向。而后面的看源码问同行是在逐步填充你这个架构，在细节方面丰满它。</p><p>套框架的总体思路是先搭建一个架子，然后往里面填充内容。即使刚开始搭起来的框架有点简陋，那也没关系。随着你的认知进一步发展，你的框架会逐步壮大完善的。你的认知圈子是以螺旋扩展的形式扩大的。换一个行为动力你可能更容易懂些，其实这个就是深挖。平时可能不会这么按部就班地操作，但是心里可以以深挖为方向，你会比较有动力学下去。</p><p><img src="/images/%E5%8F%8D%E9%A6%88%E5%BC%8F%E5%AD%A6%E4%B9%A0_%E6%89%A9%E5%B1%95%E6%A8%A1%E5%BC%8F.png" alt="扩展模式"></p><p>这个也可以用于解决问题上。这个思想好比光学显微镜调节中的粗调和细调。你要观察到你观察的东西，先用粗调螺旋调整到你能看清楚的大致区域，然后用细调的方式来逐步调整。如果你知道解决这个问题的大致流程，那你就可以据此进一步划分，把大的问题分解为小问题，小问题继续划分更小的问题，直到细分最小可执行颗粒，然后一个个解决。</p><p>在每一个阶段里面，大的方向由大纲提供，细节方向可以在头脑里生成。即使你把目标分解到最小可执行颗粒时候你仍然会有很多细节步骤要走的。这些细小目标可能是就是十分钟的计划，全罗列出来就比较繁琐了，心里知道就行。当一个目标执行完成后需要迅速调整，否则你可能就无所事事的空虚之中，所以让你的行动目标保持动态调整中。</p><p><img src="/images/%E5%8F%8D%E9%A6%88%E5%BC%8F%E5%AD%A6%E4%B9%A0_%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.png" alt="问题分析"></p><h3 id="2-2-自下而上提炼框架"><a href="#2-2-自下而上提炼框架" class="headerlink" title="2.2 自下而上提炼框架"></a>2.2 自下而上提炼框架</h3><p>提炼框架一般用来提炼知识点。当你不清楚知识点时候可以用此来提炼和总结。提炼框架有以下几个步骤：</p><ul><li>搜罗信息</li><li>罗列信息</li><li>分组分类</li><li>提炼框架</li><li>完善框架</li></ul><p>下面以程序员的出路为例来说明一下。</p><p><strong>(1)搜罗信息</strong></p><p>这个就不用多说了，尽你的能力去搜罗你要的信息。</p><p><strong>(2)罗列信息</strong></p><p>拿一张A4纸把你搜罗的信息全部写下来。不需要什么限制，能想到什么就写什么。</p><p>（做架构师，做管理，接私单、做测试、做金融经理、卖奶茶、开饭店，公务员、写书、做讲师、创业）<br><strong>(3)分组分类</strong><br>根据信息的差异性和共性，把各个信息分组分类。 </p><ul><li>做架构师，做管理，接私单、做讲师、创业、写书、做测试</li><li>做金融经理、卖奶茶、开饭店，公务员</li></ul><p><strong>(4)提炼框架</strong><br>根据分类出来的信息提取框架。 </p><ul><li>行业内<ul><li>做架构师，做管理，接私单、做讲师、创业、写书、做测试</li></ul></li><li>行业外<ul><li>做金融经理、卖奶茶、开饭店，公务员</li></ul></li></ul><p><strong>(5)完善框架</strong><br>根据框架不完善的地方继续补充完整。 这个过程可能要继续重复上面几个步骤。<br>在上面的程序员出路可以继续补充为: </p><ul><li>行业内<ul><li>主业<ul><li>做架构师，做管理、做讲师、创业、做测试</li></ul></li><li>副业<ul><li>接私单，写书 </li></ul></li></ul></li><li>行业外<ul><li>开店<ul><li>卖奶茶、开饭店</li></ul></li><li>其他<ul><li>做金融经理，公务员，啃老……</li></ul></li></ul></li></ul><p>整个过程是一个先发散再收敛的过程。提炼框架后，你对整个知识结构的认知就比较清晰了。</p><p>知识要有结构才好驾驭。首先把知识分解成一个个元素，然后找这些元素之间的联系。这个联系可以是旧知识也可以是新知识，一般是和旧知识联系，这样记忆更加有效。最后运用的时候，你会用这个简化的结构驾驭外部的复杂知识。</p><h2 id="三、容器化"><a href="#三、容器化" class="headerlink" title="三、容器化"></a>三、容器化</h2><p>容器是一个有边界的反馈环境。在这个有限边界的环境内，你自由探索，然后根据反馈来学习。这个环境可以是一个项目，可以是一个知识点，也可以是一本书。下面将从时间、内容、空间三方面来叙说。总得来说，时间和内容上都是一份份输出。</p><h3 id="3-1-时间一份份输出"><a href="#3-1-时间一份份输出" class="headerlink" title="3.1 时间一份份输出"></a>3.1 时间一份份输出</h3><p>无论是有多大的任务，都是时间累积而成。你到达你的目标是靠时间一份份输出的。</p><p><img src="/images/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86.png" alt="时间管理"></p><p>上面的图是时间分配的一种方式。时间是一份份输出。每一份时间里面由任务的时间和冗余时间组成。任务时间是你的学习任务执行时间，冗余时间是给你消化用的。每当你学习完一个知识点后，留出一段冗余时间来复习一下，这样效果会更好。这个的冗余时间不多，但给你直观的感受是像有无限多的时间来消化一样。这样的构造能给你有机会喘气来回顾你所学的知识点。如果一份时间不够那就再加一份，直至学会为止。一份时间可以是1小时，可以是一天，也可以是一个星期，一个月。这时间由你来定。一般选一个星期为一份会比较好点。</p><h3 id="3-2-内容一份份输出"><a href="#3-2-内容一份份输出" class="headerlink" title="3.2 内容一份份输出"></a>3.2 内容一份份输出</h3><p>内容是你目标。用上面的自上下套框架的方式，分解你的学习任务，最后分成一个个点。然后你一个个点去突破。</p><p>具体如下：</p><ul><li><p>1.选一个知识点：*****。</p></li><li><p>2.查阅资料。</p></li><li><p>3.把知识点将给你假想的学习。</p></li><li><p>4.如果卡住，继续看课本查资料。</p></li><li><p>5.租后用简洁的语言流畅地表达出来。</p></li></ul><p>想好在一份时间内你想要学到什么，然后围绕这个目标去查资料，看书。以这个目标是方向来查书，而不是顺着书上的内容顺序来学。这是一个结果思维。它和过程思维不同。结果思维是从你想要结果来规划方向，遇到问题就见招拆招。如果是过程思维，你的思维是专注于问题本身，为解决问题而解决问题。当问题解决了，你学习动力就没了。有时候你是为了维持一个勤奋的状态而勤奋的。那样你会陷入一个焦虑的循环中。一放松就焦虑，享受不了学习带来的成果。为了维持勤奋的状态，你不得不焦虑以维持前进的动力。以结果为向导就没这样的问题了。中间是否勤奋无关紧要，你是为了完成这个目标，你的动力一直都在。</p><p>这里步骤不单指一个知识点，你可以套入为一个项目。你想着未来某个时间内想要完成一个什么样的作品，然后去创作它。以向外输出的形式输出你的知识。这个输出你可以说出来，做出来，或者回想都可以。在回想的过程中哪里还模糊就去补哪里。你就自己选择合适你自己的形式来操作。</p><h3 id="3-3-空间化"><a href="#3-3-空间化" class="headerlink" title="3.3 空间化"></a>3.3 空间化</h3><p>空间化是分给空间成一块块，把你的行为和空间结合在一起，当你一进入这个空间就想做这事。这个怎么理解呢？你可以参照图书馆，你一进入图书馆，你就想看书学习。再比如，你一靠上客厅的沙发，你就想看电视一样。这里空间和某些行为联系在一起了。这里的行为有两种，一个是他人给你的，另外一个是你过去在这个空间的行为。你在图书馆，你看到别人都在看书，你行为就会向着这方向来趋近。你过去在沙发上都是在看电视的，你在这个空间就绑定了这个看电视的行为，一靠近就想看电视了。</p><p>如果过去你都是一打开电脑就娱乐的话，我想你很难静下心来学习了。因为你一边踩着刹车想要学习，一边踩着油门说我要看娱乐。要解决这个问题是找个书房，在这个书房里面你就只学习。你在这个空间内做的事情越纯粹，你和这个空间绑定越牢固。当你下次再进入这个书房内就会想着学习了。如果不得不用电脑的话，就建议你用两台电脑，一台专门用来学习，一台专门用来娱乐的。你在家学习的话就专门培养这个一个环境，这样学习才有效率。</p>]]></content>
      
      
      <categories>
          
          <category> 综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2017/09/23/Hexo_Blog/"/>
      <url>/2017/09/23/Hexo_Blog/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt; </p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown解析文章，生成的静态网页布置在GitHub上面，作为个人博客使用十分方便。本文前面部分将讲Windows10环境来搭建hexo博客，并介绍hexo博客的相关设置以及优化，后面会有linux环境下的相关配置。</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="一、Windows环境"><a href="#一、Windows环境" class="headerlink" title="一、Windows环境"></a>一、Windows环境</h1><blockquote><p>部分linux命令请在git base里面执行。</p></blockquote><h2 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h2><h3 id="1-1-1-安装git"><a href="#1-1-1-安装git" class="headerlink" title="1.1.1 安装git"></a>1.1.1 安装git</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git下载地址</a></p><p>默认安装，配置好默认的用户</p><pre><code class="bash">$ git config --global user.name &quot;you_name&quot;$ git config --global user.email you_email@example.com</code></pre><h3 id="1-1-2-安装node-js"><a href="#1-1-2-安装node-js" class="headerlink" title="1.1.2 安装node.js"></a>1.1.2 安装node.js</h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js下载地址</a></p><p>默认安装即可</p><p>用zip安装时，配置两个环境变量：一个是PATH上增加node.exe的目录D:\nodejs,一个是增加环境变量NODE_PATH,值为D:\nodejs\node_modules。目录地址转换成你的。</p><h3 id="1-1-3-安装Hexo"><a href="#1-1-3-安装Hexo" class="headerlink" title="1.1.3 安装Hexo"></a>1.1.3 安装Hexo</h3><pre><code class="bash">$ cd d:/hexo$ npm install hexo-cli -g  #安装全局环境$ hexo init blog #你的博客环境$ cd blog$ npm install    # NPM是随同NodeJS一起安装的包管理工具$ hexo g         # 或者hexo generate$ hexo s         # 或者hexo server，可以在http://localhost:4000 查看效果</code></pre><p>如果由于管理员权限而失败，可以用win+x选择”命令提示符(管理员)“来操作</p><p>到这里你已经可以看到效果了<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>。</p><h2 id="1-2-GitHub配置"><a href="#1-2-GitHub配置" class="headerlink" title="1.2 GitHub配置"></a>1.2 GitHub配置</h2><p>（1）新建一个仓库，名字要和你用户名一样，例如：you_name.github.io ，GitHub会自动识别这次仓库为pages</p><p>（2）配置ssh秘钥，私钥自行保存，公钥放GitHub上</p><pre><code class="bash">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; #或者下面这个$ ssh-keygen -t rsa -f sample                     #文件名命名为sample</code></pre><pre><code>-t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。</code></pre><p>SSH 在push的时候，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的</p><p>目录文件C:\ Users\youname\.ssh\id_rsa.pub为你的公钥，id_rsa为私钥。公钥里面的内容复制到GitHub设置里。</p><p>然后配置~/.ssh/config文件,按照实际情况删减。</p><pre><code class="bash">host github.com#  port 22#  compression yes#  hostname 192.168.0.1  user git  identityfile ~/.ssh/id_rsa</code></pre><p>（3）初始化仓库，即是上传一个任意文件上去。新建完仓库后，GitHub上会有提示。</p><p>（4）部署到GitHub上</p><p>配置博客根目录的_config.yml文件，把GitHub仓库地址配置进去。</p><pre><code class="yaml">  deploy:    type: git    repo: git@github.com:loongX/loongX.github.io.git    branch: master</code></pre><p>  这里要注意一下，yml文件以缩进来区分各个元素的，所以缩进要一致。</p><p>在部署到GitHub前先要安装一个hexo-deployer-git插件。<br>Hexo提供了<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>工具，可以帮助<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">部署Hexo到很多平台</a>。</p><pre><code class="bash">$ npm install hexo-deployer-git --save</code></pre><p>在blog文件夹里</p><pre><code class="bash">$ hexo g$ hexo d  #部署到远程仓上。</code></pre><p>这里会部署到GitHub上，打开你的pages网址可以看到内容了（类似这个loongX.github.io网址）。</p><p>这个部署上传的是public目录下的文件，public文件夹里面保存的是生成的静态文件。</p><h2 id="1-3-Hexo-建设"><a href="#1-3-Hexo-建设" class="headerlink" title="1.3 Hexo 建设"></a>1.3 Hexo 建设</h2><p> <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></p><h3 id="1-3-1-目录结构"><a href="#1-3-1-目录结构" class="headerlink" title="1.3.1 目录结构"></a>1.3.1 目录结构</h3><p>blog目录结构如下</p><pre><code>.├── _config.yml   #配置文件├── package.json  #应用程序的信息├── scaffolds     #模版文件夹├── source        #资源文件夹是存放用户资源的地方|   ├── _drafts   #草稿|   └── _posts    #正文└── themes        #主题文件夹</code></pre><h3 id="1-3-2-基础命令"><a href="#1-3-2-基础命令" class="headerlink" title="1.3.2 基础命令"></a>1.3.2 基础命令</h3><pre><code class="bash">$ hexo generate                # 简写：hexo g，生成静态文件，会在当前目录下生成一个public文件夹$ hexo server                  # 简写：hexo s，启动本地服务，用于博客的预览$ hexo deploy                  # 简写：hexo d，部署到远程（如GitHub，可以在_config.yml中配置）$ hexo new post-name           # 简写：hexo n post-name， 新建文章 $ hexo new page page-name      # 简写：hexo n page page-name，新建页面$ hexo d -g                    # 生成和部署$ hexo s -g                    # 生成和预览$ hexo new draft &lt;title&gt;       # 新建草稿，存放在source/_drafts$ hexo publish post &lt;title&gt;    # 发布草稿为文章，文章转移到source/_posts$ hexo s -g --drafts           # 显示草稿$ hexo new page tags           # 使用 Hexo 命令新建一个名为 tags 的页面$ hexo s -p 5000               # 更改端口号为5000</code></pre><h3 id="1-3-3-更换主题"><a href="#1-3-3-更换主题" class="headerlink" title="1.3.3 更换主题"></a>1.3.3 更换主题</h3><pre><code class="bash">$ hexo clean$ git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee</code></pre><p>然后修改Hexo目录下的<code>_config.yml</code>配置文件中的theme属性，将其设置为yelee。</p><h3 id="1-3-4-添加插件"><a href="#1-3-4-添加插件" class="headerlink" title="1.3.4 添加插件"></a>1.3.4 添加插件</h3><p>RSS 对应插件——feed插件<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a></p><p>Sitemap for SEO 站点地图通用插件: <a href="https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap" target="_blank" rel="noopener">hexo-generator-seo-friendly-sitemap</a></p><p>百度专用Sitemap: <a href="https://github.com/coneycode/hexo-generator-baidu-sitemap" target="_blank" rel="noopener">hexo-generator-baidu-sitemap</a></p><p>添加插件添加sitemap和feed插件</p><pre><code>$ npm install hexo-generator-feed $ npm install hexo-generator-sitemap $ npm install hexo-generator-baidu-sitemap@0.1.1 --save</code></pre><p>修改_config.yml，增加以下内容</p><pre><code class="bash">Plugins:- hexo-generator-feed- hexo-generator-sitemap- hexo-generator-baidu-sitemap#Feed Atomfeed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: &#39; &#39;#通用sitemapsitemap: path: sitemap.xml #百度爬虫baidusitemap:path: baidusitemap.xml</code></pre><p>配完之后，就可以访问<code>http://loongx.github.io/atom.xml</code>和<code>http://loongx.github.io/sitemap.xml</code>，发现这两个文件已经成功生成了。</p><h3 id="1-3-5-绑定独立域名"><a href="#1-3-5-绑定独立域名" class="headerlink" title="1.3.5 绑定独立域名"></a>1.3.5 绑定独立域名</h3><p>先购买域名：</p><p><a href="http://www.net.cn/" target="_blank" rel="noopener">阿里云域名购买</a></p><p><a href="https://sg.godaddy.com/" target="_blank" rel="noopener">godaddy域名购买</a></p><p>然后在你的域名注册提供商那里配置DNS解析，你可以解析到ip也可也解析到域名</p><p>CNAME — www —默认线路—loongx.githut.io</p><p>CNAME—-@—-默认线路 —–loongx.githut.io</p><p>进入source目录下，添加CNAME文件</p><pre><code class="bash">$ cd source/$ touch CNAME$ echo &quot;okloong.com&quot; &gt;&gt; CNAME # 输入你的域名</code></pre><p>如果你按照下面步骤做了，在coding上也同样做了一个pages的话，你可以把国内的访问引向coding，国外的访问引向GitHub。</p><p>CNAME — www —默认线路—okayloong.coding.me</p><p>CNAME—-@—-默认线路 —–okayloong.coding.me</p><p>CNAME — www —海外线路—loongx.githut.io</p><p>CNAME—-@—-海外线路 —–loongx.githut.io</p><h3 id="1-3-6-写博客"><a href="#1-3-6-写博客" class="headerlink" title="1.3.6 写博客"></a>1.3.6 写博客</h3><ul><li>markdown编辑器</li></ul><p>hexo写博客是用markdown语法来写的，用具有markdown功能的软件会比较方便些，我这里用的是<strong>Typora</strong>，简单好用。</p><ul><li>文章目录分类</li></ul><p>在\source\_posts文件夹里面支持文件夹形式。如果你觉得你文章太多，想分类，你可以直接新建文件夹来分类各个文章，hexo会识别到文件夹里面的文件的。这样做只是为了你方便好看，但是hexo会忽略你的文件夹名字。</p><ul><li>插入本地图片</li></ul><p>使用本地路径：在hexo/source目录下新建一个img文件夹（其他名称也行），将图片放入该文件夹下，插入图片时链接即为：‘/img/图片名称’。 如果你用了文件夹放请加上文件夹名词，hexo这次会连带文件夹生成路径。</p><pre><code>![picture](/img/aaa/Koala.jpg)</code></pre><ul><li>插入歌曲</li></ul><p>这示例里面的链接是网易云音乐的分享链接</p><pre><code>&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86       src=&quot;http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66&quot;&gt;  &lt;/iframe&gt; </code></pre><ul><li>插入视频</li></ul><pre><code>&lt;iframe    height=498 width=510       src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot;       frameborder=0 allowfullscreen&gt;  &lt;/iframe&gt;  </code></pre><h2 id="1-4-主题配置"><a href="#1-4-主题配置" class="headerlink" title="1.4 主题配置"></a>1.4 主题配置</h2><h3 id="1-4-1-yelee主题"><a href="#1-4-1-yelee主题" class="headerlink" title="1.4.1 yelee主题"></a>1.4.1 yelee主题</h3><p><a href="http://moxfive.coding.me/yelee" target="_blank" rel="noopener">yelee官方文档</a></p><p>大部分设置只要在主题下的_config.yml文件里配置就可以了，里面的注释说得很清楚了，官方文档也说得很详细。下面说一些特殊的。</p><blockquote><p><strong>配置文件中参数紧接的冒号后面都需要加一个空格！包括文章头的标题框里面的设置也是。</strong></p></blockquote><h4 id="1-4-1-1-标签、分类以及我的页面设置"><a href="#1-4-1-1-标签、分类以及我的页面设置" class="headerlink" title="1.4.1.1 标签、分类以及我的页面设置"></a>1.4.1.1 标签、分类以及我的页面设置</h4><p>1.标签云设置：<br>使用 Hexo 命令新建一个名为 tags 的页面即可</p><pre><code class="bash">hexo new page tags</code></pre><p>2.关于我页面</p><p>使用 Hexo 命令新建一个名为 about 的页面即可</p><pre><code class="bash">hexo new page about</code></pre><blockquote><p>该页面内容在文件 \hexo\source\about\index.md 中修改</p></blockquote><p>然后，将上面两个在下面配置中建立链接关系。</p><pre><code class="yaml">menu:  主页: /  所有文章: /archives/  标签云: /tags/  关于我: /about/</code></pre><blockquote><p>注意：<br>在hexo里面已经包含了tags和cataloges相关的设置了，不需要新建catalages page，分类和标签会显示在标签云里面。如果你在使用hexo new page catalages创建一个catalages分类，会只显示一个空白网页。</p></blockquote><p> <strong>博客模板修改</strong></p><p>将<code>\freeshow.github.io\scaffolds</code>下的post.md模板文件修改为如下：</p><pre><code class="markdown">---title: {{ title }}date: {{ date }}tags:categories:---</code></pre><p>当写文件时，就可以填写所属tags或categories了。<br>tags和categories都会显示在 <code>标签云</code> 中.</p><h4 id="1-4-1-2-修改文章置顶"><a href="#1-4-1-2-修改文章置顶" class="headerlink" title="1.4.1.2 修改文章置顶"></a>1.4.1.2 修改文章置顶</h4><p>主要是修改文章的排列规则</p><p><code>node_modules/hexo-generator-index/lib/generator.js</code></p><pre><code class="javascript">&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);module.exports = function(locals) {  var config = this.config;  var posts = locals.posts.sort(config.index_generator.order_by);  var paginationDir = config.pagination_dir || &#39;page&#39;;  var path = config.index_generator.path || &#39;&#39;;//****************开始添加*********  posts.data = posts.data.sort(function(a, b) {        if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排            else return b.top - a.top; // 否则按照top值降序排        }        else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）            return -1;        }        else if(!a.top &amp;&amp; b.top) {            return 1;        }        else return b.date - a.date; // 都没定义按照文章日期降序排    });  //****************添加结束*********  return pagination(path, posts, {    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;/%d/&#39;,    data: {      __index: true    }  });};</code></pre><p>然后在文章中，增加top值定义，值越大，文章排序越靠前。top值默认为0，若不设置top，则不参与排序。示例：</p><pre><code class="markdown">title: 为Hexo添加文章置顶功能categories: sampletags: simpletop: 1date: 2016-07-20 11:44:40</code></pre><p>如果想按更新时间排序：改一下上面的代码 中的<code>a.date</code>, <code>b.date</code> 分别改为 <code>a.updated</code>, <code>b.updated</code></p><h4 id="1-4-1-3-其他设置"><a href="#1-4-1-3-其他设置" class="headerlink" title="1.4.1.3 其他设置"></a>1.4.1.3 其他设置</h4><p><a href="https://github.com/MOxFIVE/hexo-theme-yelee/pull/186" target="_blank" rel="noopener">增加文章打赏功能</a><br><a href="https://github.com/MOxFIVE/hexo-theme-yelee/pull/173" target="_blank" rel="noopener">修复404在非根目录下错误链接，导致style.css无法正确获取</a></p><h3 id="1-4-2-Next主题"><a href="#1-4-2-Next主题" class="headerlink" title="1.4.2 Next主题"></a>1.4.2 Next主题</h3><p>Next是hexo框架上的一个主题。由于它简洁清晰，受很多人追捧。我也没忍住将个人博客主题换成next主题来试下效果。下面将讲述hexo的next主题的相关设置。</p><h4 id="1-4-2-1-添加标签页面"><a href="#1-4-2-1-添加标签页面" class="headerlink" title="1.4.2.1 添加标签页面"></a>1.4.2.1 添加标签页面</h4><ul><li>新建页面</li></ul><p>输入如下命令：</p><pre><code>$ hexo new page tags</code></pre><p>输入命令后，在<code>myBlog/source</code>下会新生成一个新的文件夹<code>tags</code>，在该文件夹下会有一个<code>index.md</code>文件。</p><ul><li>设置页面类型</li></ul><p>在上步新生成的<code>myBlog/source/tags/index.md</code>中添加<code>type: &quot;tags&quot;</code>，<code>index.md</code>文件内容如下：</p><pre><code>---title: 分类&amp;标签type: &quot;tags&quot;date: 2017-09-22 00:30:37---</code></pre><ul><li>设置具体文章的tags</li></ul><p>当要为某一篇文章添加标签，只需在<code>myBlog/source/_post</code>目录下的具体文章的tags中添加标签即可，如：</p><pre><code>---title: Next主题设置date: 2017-10-31 10:10:12tags: hexocategories:---</code></pre><h4 id="1-4-2-2-添加分类页面"><a href="#1-4-2-2-添加分类页面" class="headerlink" title="1.4.2.2 添加分类页面"></a>1.4.2.2 添加分类页面</h4><p>步骤与添加标签页面类似，具体如下：</p><ul><li>新建页面</li></ul><p>输入如下命令：</p><pre><code>hexo new page categories</code></pre><p>输入命令后，在<code>myBlog/source</code>下会新生成一个新的文件夹<code>categories</code>，在该文件夹下会有一个<code>index.md</code>文件。</p><ul><li>设置页面类型</li></ul><p>在上步新生成的<code>myBlog/source/categories/index.md</code>中添加<code>type: &quot;categories&quot;</code>，<code>index.md</code>文件内容如下：</p><pre><code>---title: categoriesdate: 2017-10-31 10:36:29type: &quot;categories&quot;---</code></pre><ul><li>设置具体文章的categories</li></ul><p>当要为某一篇文章添加分类，只需在<code>myBlog/source/_post</code>目录下的具体文章的categories中添加分类即可，如：</p><pre><code>---title: Next主题设置date: 2017-10-31 10:10:12tags: hexocategories:---</code></pre><h4 id="1-4-2-3-修改内容区域的宽度"><a href="#1-4-2-3-修改内容区域的宽度" class="headerlink" title="1.4.2.3 修改内容区域的宽度"></a>1.4.2.3 修改内容区域的宽度</h4><p>我们用Next主题是发现在电脑上阅读文章时内容两边留的空白较多，这样在浏览代码块时经常要滚动滚动条才能阅读完整，体验不是很好，下面提供修改内容区域的宽度的方法。<br>Next 对于内容的宽度的设定如下：</p><ul><li>700px，当屏幕宽度 &lt; 1600px</li><li>900px，当屏幕宽度 &gt;= 1600px</li><li>移动设备下，宽度自适应</li></ul><p>如果你需要修改内容的宽度，同样需要编辑样式文件。<br>在Mist和Muse风格可以用下面的方法：<br>编辑主题的 source/css/_variables/custom.styl 文件，新增变量：</p><pre><code>// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px</code></pre><p>当你使用Pisces风格时可以用下面的方法，在 source/css/_variables/custom.styl 中添加：</p><pre><code>$main-desktop                   = 1200px$content-desktop                = 900px</code></pre><h4 id="1-4-3-4-分享样式修改"><a href="#1-4-3-4-分享样式修改" class="headerlink" title="1.4.3.4 分享样式修改"></a>1.4.3.4 分享样式修改</h4><p>jiathis样式可以在目录themes\next\layout_partials\share下的jiathis.swig文件里面修改。<br>在我的博客里，我把文字和栏目作了调整。<a href="http://www.jiathis.com/" target="_blank" rel="noopener">官网</a>上也有对应的代码参考。</p><pre><code>&lt;span class=&quot;jiathis_txt&quot;&gt;&lt;/span&gt;&lt;a class=&quot;jiathis_button_tsina&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_tqq&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_weixin&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_cqq&quot;&gt;&lt;/span&gt;&lt;a class=&quot;jiathis_button_qzone&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_douban&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_fav&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_copy&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_email&quot;&gt;&lt;/a&gt;&lt;a class=&quot;jiathis_button_share&quot;&gt;&lt;/a&gt;</code></pre><h2 id="1-5-Coding设置"><a href="#1-5-Coding设置" class="headerlink" title="1.5 Coding设置"></a>1.5 Coding设置</h2><p>Coding像GitHub一样也提供pages功能，配置方法和GitHub配置差不多。这里用Coding是因为，GitHub在国内访问是比较慢的，Coding在国内访问就比较快一点，而且也方便百度搜索引擎抓取。在设置dns时候，把国内访问的流量引向Coding上，国外线访问就引向GitHub上，这样就比较合理一点。</p><h3 id="1-5-1-配置ssh秘钥"><a href="#1-5-1-配置ssh秘钥" class="headerlink" title="1.5.1 配置ssh秘钥"></a>1.5.1 配置ssh秘钥</h3><p>按照上面的给GitHub配置ssh秘钥的步骤同样给coding平台布置即可。</p><h3 id="1-5-2-建立coding-pages"><a href="#1-5-2-建立coding-pages" class="headerlink" title="1.5.2 建立coding-pages"></a>1.5.2 建立coding-pages</h3><p>下面是创建一个「项目 Pages」的操作示例：</p><p><strong>这里另外找一个test文件夹来测试就好了。</strong></p><p>1.登录 Coding.net，创建一个项目，项目名称为：user_name.coding.me</p><p>2.在本地创建一个项目文件夹，添加一个测试用的 index.html 文件。</p><pre><code class="html">&lt;html&gt;   &lt;head&gt;     &lt;title&gt;My Coding Pages&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;      &lt;h1&gt;Hello Coding!&lt;/h1&gt;   &lt;/body&gt;&lt;/html&gt;</code></pre><p>3.将项目文件夹初始化为 Git 版本库，提交 index.html 到版本库，并为项目添加远程仓库地址。</p><pre><code class="bash">git initgit add index.htmlgit commit -m &#39;init&#39;git remote add origin  git@git.coding.net:{user_name}/{project_name}</code></pre><blockquote><p>请别忘记将上面代码中的远程仓库地址的 {user_name} 和 {project _name} 替换成你自己的个性后缀（Global Key）和项目地址。</p></blockquote><p>4.在本地创建一个 <code>coding-pages</code> 分支，切换到该分支。</p><pre><code>git checkout -b coding-pages</code></pre><p>5.将 coding-pages 分支推送到 Coding.net。</p><pre><code>git push origin coding-pages</code></pre><p>6.在项目的「Pages 服务」设置中，选择部署来源为 <code>coding-pages</code> 分支，点击「保存」按钮。 稍等片刻即可完成部署并通过 <code>{user_name}.coding.me／{project_name}</code> 访问你的网站.</p><h3 id="1-5-3-部署博客"><a href="#1-5-3-部署博客" class="headerlink" title="1.5.3 部署博客"></a>1.5.3 部署博客</h3><p>在你的博客目录</p><p>在你博客根目录下的_config.yml文件里配置</p><pre><code class="yaml">deploy:  type: git  repo:      github: git@github.com:loongX/loongX.github.io.git,master     coding: git@git.coding.net:OkayLoong/Okayloong.coding.me.git,coding-pages</code></pre><p>部署到平台上：</p><pre><code class="bash">hexo d -g</code></pre><h3 id="1-5-4-自定义域名"><a href="#1-5-4-自定义域名" class="headerlink" title="1.5.4 自定义域名"></a>1.5.4 自定义域名</h3><p>coding的普通用户不能自定域名，也就是说你刚刚注册到的账户是没有这个功能的，你需要补充完资料，升级账户才能用。升级账户后，在“pages服务”里添加进你的域名进去，并配置好dns解析就好了。</p><h2 id="1-6-Hexo多电脑同步的方法"><a href="#1-6-Hexo多电脑同步的方法" class="headerlink" title="1.6 Hexo多电脑同步的方法"></a>1.6 Hexo多电脑同步的方法</h2><p>一般思路是，创建两个仓库，一个用来保存hexo源码，一个是用来保存生成的博客文件。为了源码的安全建议是把源码保存在一个私有仓内。这里我采用coding建立私有库。码云也提供私有库功能，方法类似。</p><p>说下这个两个仓库的结构：</p><p>Hexo-blog分支 – 用来保存所有Hexo的源文件</p><p>master分支 – 用来保存Hexo生成的博客文件</p><h3 id="1-6-1-创建私有仓库"><a href="#1-6-1-创建私有仓库" class="headerlink" title="1.6.1 创建私有仓库"></a>1.6.1 创建私有仓库</h3><p>在coding平台上创建一个私有项目，名称为Hexo-blog，并初始化仓库（按照上面的要求上传一个任意文件上去，否则后面的操作会报错）。</p><p>上传时候需要把主题里面的.git文件夹删掉，要不然上传到私有库时候会漏掉主题部分的代码的。</p><p>但这个有个问题，你删后，原来主题的有更新就得不到及时更新了。</p><pre><code class="bash">rm -fr ./themes/yelee/.git/   #删除主题里面的gitgit init                     #建立本地的git仓库git remote add origin git@git.coding.net:OkayLoong/hexo-blog.git  #添加远程仓，注意要添加ssh秘钥git add .git commit -m &quot;my first private hexo&quot;git push -u origin master</code></pre><p>但是如果你的主题改动比较大，更新反而很多冲突，那自己维护也行。不过这里有个取巧的办法。</p><p>主题刚下载还没同步到私有仓时候，把主题里面的.git文件夹删除掉，同步一下私有仓，然后<strong>撤销删除</strong>，把主题里面的.git文件夹还原回来。这时候，你两边的仓库都能更新了。</p><p>上传私有仓</p><pre><code class="bash">git status                     #这个只是查看状态，可以不写git add .                      #把整个文件夹添加进去git commit -m &quot;update&quot;         #git规定一定要写，要不然上传不了git push origin master         #简写 git push </code></pre><p>可以将上面的代码保存为deploy.sh，这样就不用每次都敲了。但注意不要用中文名。</p><p>拉取私有仓回本地</p><p>一般<code>git pull</code>就够了，但是如果有冲突可以按照下面的方式来解决，以远程仓库为标准代码覆盖原来的。</p><pre><code class="bash">git fetch --all                  #将git上所有文件拉取到本地git reset --hard origin/master   #强制将本地内容指向刚刚同步git云端内容</code></pre><h2 id="1-7-优化"><a href="#1-7-优化" class="headerlink" title="1.7 优化"></a>1.7 优化</h2><h3 id="1-7-1-图片优化"><a href="#1-7-1-图片优化" class="headerlink" title="1.7.1 图片优化"></a>1.7.1 图片优化</h3><p>图片存放有两种方式，图片可放到CDN上缓存，或者放到本地保存，然后调用时候写上图片的链接或路径即可。我选择了放到本地。但是这么做会有两个问题，如果文章目录比较深，而图片放到/source/images目录下面的话，编写文章时候写的路径不会有预览，要替换图片时候，不好找图片，也不方便管理。针对这问题，我是把图片放到和文章同一级目录下的images文件夹，这样管理和预览这两个问题就很好解决了。生成博客时候需要把图片提取到/source/images目录下。</p><p>为了方便管理我做了一个下面这么一个脚本。</p><ul><li>update-picture.sh</li></ul><pre><code class="shell">#!/bin/sh#文章图片放到文章当前的images文件夹下面，这主要是为了写文章方便看图#生成博客时候把图片同步到./source/images目录下echo &quot;######  rmove&quot;    rm -rfv ./source/images/*    echo &quot;######  copy&quot;find ./source/_posts  -name &#39;images&#39; -type d | xargs -i cp -avx {} ./source/find ./source/system  -name &#39;images&#39; -type d | xargs -i cp -avx {} ./source/</code></pre><p>git上传源码时候如果连同/source/images目录下的图片一并上传的话，那么会有两份相同图片，一份是文章目录下的图片，另外一份是这个/source/images目录下的，鉴此，我就忽略上传/source/images文件夹了。在ignore文件里面添加<code>source/images/</code>。如果之前有同步过这个文件夹下的图片，那么则需要删掉缓存和git后台的对应文件。</p><p>还有一点就是，如果这么做，图片要起一个全局唯一的名称，或者在image里面设置多重文件夹里面来区分识别。</p><h1 id="二、Linux环境"><a href="#二、Linux环境" class="headerlink" title="二、Linux环境"></a>二、Linux环境</h1><p>大部分会和Windows差不多，重复的就不多说了。我用的是Ubuntu系统。</p><h2 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h2><p>安装node.js, npm ,hexo</p><ul><li><p>安装node.js,npm</p><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载源码,然后解压,进入起文件夹进行编译.如果你下的是二进制文件就复制到对应文件夹下面,并添加环境变量.</p><pre><code class="shell">./configure --prefix=/usr/local/node/node-v8.9.1 #配置参数,指定了安装目录makesudo make installsudo gedit /etc/profile#添加路径进去#后来用sudo执行时候没有这个环境变量,我也在/root/.bashrc下添加了路径#set for nodejsexport NODE_HOME=/usr/local/node/node-v8.9.1export PATH=$NODE_HOME/bin:$PATH#一般是重启会设置路径,如果想立刻看到效果,执行下面的命令source /etc/profilenode -vnpm -v</code></pre><p>除了源码编译外,你也可以下载编译好的包,解压到对应文件夹</p><p>下面这个是直接安装方式,但是版本会比较旧</p><pre><code>sudo apt install nodejssudo apt isntall npm</code></pre><p>其他命令</p><pre><code>npm install npm -g  #升级npmnpm install module_name #安装模块npm ls -g   #查看所有全局安装的npm模块npm uninstall module_name #卸载模块npm update module_name #升级模块</code></pre></li><li><p>安装hexo</p><pre><code>npm install -g hexo-cli</code></pre><p>执行这个时候可能会有权限问题，因为你用的是sudo的权限make进去的，用户拥有者为root，同一个用户组没有写权限。你可以用下面的命令修改。</p><pre><code>sudo chmod -R 775 /usr/local/node #更改权限#或者下面这条命令sudo chown -R ubuntu:root /usr/local/node #更改拥有者</code></pre><p>-R参数是递归 处理目录下的所有文件以及子文件</p><p>775是权限设置</p><p>ubuntu:root表示用户和用户组,用户组非必须。</p></li><li><p>blog源码移植</p><p>你之前的blog是在windows系统上写的，现在移植到Ubuntu系统上，那么只要下载blog代码到本地，添加node的相关插件，基本可以了。</p><p>如果你是有写脚步来辅助的，可能会并没有相关的执行权限。可以用下面的方式来添加执行权限。</p><pre><code class="shell">find *.sh | xargs -i chmod +x {}</code></pre><p>出现“pull.sh: 5: pull.sh: Syntax error: “(“ unexpected”错误，那是因为Ubuntu系统默认的sh为Dash，语法有点不同。脚步里面可以改为<code>#!/bin/bash</code> 或 <code>#!/usr/bin/env bash</code>。但是为了windows端和linux端同步，我决定改该shell为bash shell。</p><pre><code class="shell">sudo dpkg-reconfigure dash #选择”否“ls -l /bin/sh #查看效果</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
